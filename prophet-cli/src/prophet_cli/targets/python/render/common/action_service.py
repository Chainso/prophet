from __future__ import annotations

from typing import Any, Dict, List

from ..support import _camel_case
from ..support import _pascal_case
from ..support import _snake_case
from ..support import _sort_dict_entries


def render_action_service(ir: Dict[str, Any], *, async_mode: bool) -> str:
    action_input_by_id = {item["id"]: item for item in ir.get("action_inputs", []) if isinstance(item, dict) and "id" in item}
    event_by_id = {item["id"]: item for item in ir.get("events", []) if isinstance(item, dict) and "id" in item}
    output_event_helpers = sorted(
        {
            f"create_{_snake_case(_pascal_case(str(event_by_id.get(str(action.get('output_event_id', '')), {}).get('name', 'Event'))))}_event"
            for action in ir.get("actions", [])
            if isinstance(action, dict)
        }
    )

    lines: List[str] = [
        "# Code generated by prophet-cli. DO NOT EDIT.",
        "from __future__ import annotations",
        "",
        "from prophet_events_runtime import create_event_id",
        "",
        "from .action_handlers import ActionContext",
        "from .action_handlers import ActionHandlers",
        "from .actions import *",
        "from .event_contracts import *",
        "from .events import EventPublishMetadata",
        "from .events import publish_domain_events",
        "from .events import publish_domain_events_sync",
        "from .events import to_action_outcome",
        "from .events import " + ", ".join(output_event_helpers),
        "",
        "class ActionExecutionService:",
        "    def __init__(self, handlers: ActionHandlers):",
        "        self.handlers = handlers",
        "",
    ]

    for action in _sort_dict_entries([item for item in ir.get("actions", []) if isinstance(item, dict)]):
        action_name = str(action.get("name", "action"))
        camel = _camel_case(action_name)
        input_shape = action_input_by_id.get(str(action.get("input_shape_id", "")), {})
        input_name = _pascal_case(str(input_shape.get("name", "ActionInput")))
        output_name = _pascal_case(str(event_by_id.get(str(action.get("output_event_id", "")), {}).get("name", "Event")))
        output_event_helper = f"create_{_snake_case(output_name)}_event"

        if async_mode:
            lines.append(f"    async def execute_{camel}(self, input: {input_name}, context: ActionContext) -> {output_name}:")
            lines.append(f"        result = await self.handlers.{camel}.handle(input, context)")
            lines.append("        outcome = to_action_outcome(result)")
            lines.append("        metadata = EventPublishMetadata(")
            lines.append("            trace_id=context.traceId or create_event_id(),")
            lines.append(f"            source=context.eventSource or '{str(ir.get('ontology', {}).get('name', 'prophet'))}',")
            lines.append("            attributes=context.eventAttributes,")
            lines.append("        )")
            lines.append(f"        events = [{output_event_helper}(outcome.output), *outcome.additional_events]")
            lines.append("        await publish_domain_events(context.eventPublisher, events, metadata)")
            lines.append("        return outcome.output")
        else:
            lines.append(f"    def execute_{camel}(self, input: {input_name}, context: ActionContext) -> {output_name}:")
            lines.append(f"        result = self.handlers.{camel}.handle(input, context)")
            lines.append("        outcome = to_action_outcome(result)")
            lines.append("        metadata = EventPublishMetadata(")
            lines.append("            trace_id=context.traceId or create_event_id(),")
            lines.append(f"            source=context.eventSource or '{str(ir.get('ontology', {}).get('name', 'prophet'))}',")
            lines.append("            attributes=context.eventAttributes,")
            lines.append("        )")
            lines.append(f"        events = [{output_event_helper}(outcome.output), *outcome.additional_events]")
            lines.append("        publish_domain_events_sync(context.eventPublisher, events, metadata)")
            lines.append("        return outcome.output")
        lines.append("")

    return "\n".join(lines).rstrip() + "\n"
