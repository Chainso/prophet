from __future__ import annotations

from typing import Any, Dict, List

from ..support import _pascal_case
from ..support import _snake_case


def render_event_emitter(ir: Dict[str, Any], *, async_mode: bool) -> str:
    action_output_by_id = {item["id"]: item for item in ir.get("action_outputs", []) if isinstance(item, dict) and "id" in item}
    schema_version = str(ir.get("ontology", {}).get("version", "1.0.0"))

    event_specs: List[Dict[str, str]] = []
    seen_event_names: set[str] = set()
    for event in sorted([item for item in ir.get("events", []) if isinstance(item, dict)], key=lambda item: str(item.get("id", ""))):
        kind = str(event.get("kind", ""))
        if kind not in {"action_output", "signal"}:
            continue
        event_name = _pascal_case(str(event.get("name", "Event")))
        if event_name in seen_event_names:
            continue
        seen_event_names.add(event_name)
        if kind == "action_output":
            shape_id = str(event.get("output_shape_id", ""))
            payload_type = _pascal_case(str(action_output_by_id.get(shape_id, {}).get("name", event_name)))
            payload_source = "Actions"
        else:
            payload_type = event_name
            payload_source = "EventContracts"
        event_specs.append({"name": event_name, "payload_type": payload_type, "payload_source": payload_source})

    lines: List[str] = [
        "# Code generated by prophet-cli. DO NOT EDIT.",
        "from __future__ import annotations",
        "",
        "import dataclasses",
        "",
        "from dataclasses import dataclass",
        "from dataclasses import field",
        "from typing import Generic, List, Literal, Optional, Protocol, TypeVar, Union",
        "",
        "from prophet_events_runtime import EventPublisher",
        "from prophet_events_runtime import EventWireEnvelope",
        "from prophet_events_runtime import NoOpEventPublisher",
        "from prophet_events_runtime import create_event_id",
        "from prophet_events_runtime import now_iso",
        "from prophet_events_runtime import publish_batch_sync",
        "",
        "from . import actions as Actions",
        "from . import event_contracts as EventContracts",
        "",
        "TOutput = TypeVar('TOutput')",
        "",
        "@dataclass(kw_only=True)",
        "class EventPublishMetadata:",
        "    trace_id: str",
        "    source: str",
        "    attributes: Optional[dict[str, str]] = None",
        "",
        "@dataclass(kw_only=True)",
        "class ActionOutcome(Generic[TOutput]):",
        "    output: TOutput",
        "    additional_events: List[DomainEvent] = field(default_factory=list)",
        "",
        "ActionOutcomeValue = Union[TOutput, ActionOutcome[TOutput]]",
        "",
    ]

    domain_event_types: List[str] = []
    for spec in event_specs:
        event_name = spec["name"]
        payload_type = spec["payload_type"]
        payload_source = spec["payload_source"]
        wrapper_name = f"{event_name}DomainEvent"
        domain_event_types.append(wrapper_name)
        lines.extend(
            [
                "@dataclass(kw_only=True)",
                f"class {wrapper_name}:",
                f"    type: Literal['{event_name}'] = '{event_name}'",
                f"    payload: {payload_source}.{payload_type}",
                "",
            ]
        )
    if domain_event_types:
        lines.append(f"DomainEvent = Union[{', '.join(domain_event_types)}]")
    else:
        lines.append("DomainEvent = object")
    lines.append("")

    lines.extend(
        [
            "def just(output: TOutput) -> ActionOutcome[TOutput]:",
            "    return ActionOutcome(output=output, additional_events=[])",
            "",
            "def with_events(output: TOutput, *additional_events: DomainEvent) -> ActionOutcome[TOutput]:",
            "    return ActionOutcome(output=output, additional_events=list(additional_events))",
            "",
            "def to_action_outcome(value: ActionOutcomeValue[TOutput]) -> ActionOutcome[TOutput]:",
            "    if isinstance(value, ActionOutcome):",
            "        return value",
            "    return just(value)",
            "",
        ]
    )

    for spec in event_specs:
        event_name = spec["name"]
        payload_type = spec["payload_type"]
        payload_source = spec["payload_source"]
        lines.extend(
            [
                f"def create_{_snake_case(event_name)}_event(payload: {payload_source}.{payload_type}) -> {event_name}DomainEvent:",
                f"    return {event_name}DomainEvent(payload=payload)",
                "",
            ]
        )

    lines.extend(
        [
            "def _serialize_payload(payload: object) -> dict[str, object]:",
            "    if dataclasses.is_dataclass(payload):",
            "        return dataclasses.asdict(payload)",
            "    if isinstance(payload, dict):",
            "        return payload",
            "    return {'value': str(payload)}",
            "",
            "def _to_event_wire_envelope(event: DomainEvent, metadata: EventPublishMetadata) -> EventWireEnvelope:",
            "    return EventWireEnvelope(",
            "        event_id=create_event_id(),",
            "        trace_id=metadata.trace_id,",
            "        event_type=getattr(event, 'type', 'unknown'),",
            f"        schema_version='{schema_version}',",
            "        occurred_at=now_iso(),",
            "        source=metadata.source,",
            "        payload=_serialize_payload(getattr(event, 'payload', {})),",
            "        attributes=metadata.attributes,",
            "    )",
            "",
            "async def publish_domain_events(",
            "    event_publisher: EventPublisher,",
            "    events: List[DomainEvent],",
            "    metadata: EventPublishMetadata,",
            ") -> None:",
            "    if not events:",
            "        return None",
            "    envelopes = [_to_event_wire_envelope(event, metadata) for event in events]",
            "    await event_publisher.publish_batch(envelopes)",
            "",
            "def publish_domain_events_sync(",
            "    event_publisher: EventPublisher,",
            "    events: List[DomainEvent],",
            "    metadata: EventPublishMetadata,",
            ") -> None:",
            "    if not events:",
            "        return None",
            "    envelopes = [_to_event_wire_envelope(event, metadata) for event in events]",
            "    publish_batch_sync(event_publisher, envelopes)",
            "",
            "EventPublisherNoOp = NoOpEventPublisher",
            "",
        ]
    )

    lines.append("")
    return "\n".join(lines).rstrip() + "\n"
