from __future__ import annotations

from typing import Any, Dict, List, Set

from ..support import _camel_case
from ..support import _object_primary_key_fields
from ..support import _pascal_case
from ..support import _sort_dict_entries


def render_transition_services(ir: Dict[str, Any], *, async_mode: bool) -> str:
    objects = [item for item in ir.get("objects", []) if isinstance(item, dict)]
    object_by_id = {str(item.get("id", "")): item for item in objects}
    transition_events = [
        item
        for item in ir.get("events", [])
        if isinstance(item, dict) and str(item.get("kind", "")) == "transition"
    ]
    event_by_transition_id = {
        str(item.get("transition_id", "")): item
        for item in transition_events
        if str(item.get("transition_id", ""))
    }

    lines: List[str] = [
        "# Code generated by prophet-cli. DO NOT EDIT.",
        "from __future__ import annotations",
        "",
        "from dataclasses import dataclass",
        "from dataclasses import field",
        "from typing import Dict, Optional, Protocol, Union",
        "",
        "from prophet_events_runtime import TransitionValidationResult",
        "",
        "from .domain import *",
        "from .event_contracts import *",
        "from .persistence import Repositories",
        "",
    ]

    transition_objects = []
    for obj in _sort_dict_entries(objects):
        transitions = [
            item
            for item in _sort_dict_entries([entry for entry in obj.get("transitions", []) if isinstance(entry, dict)])
            if str(item.get("id", "")) in event_by_transition_id
        ]
        if transitions:
            transition_objects.append((obj, transitions))

    if not transition_objects:
        lines.append("class TransitionHandlers(Protocol):")
        lines.append("    pass")
        lines.append("")
        lines.append("class TransitionServices:")
        lines.append("    def __init__(self, repositories: Repositories, handlers: Optional[TransitionHandlers] = None):")
        lines.append("        self._repositories = repositories")
        lines.append("        self._handlers = handlers")
        lines.append("")
        return "\n".join(lines).rstrip() + "\n"

    event_metadata_by_transition_id: Dict[str, Dict[str, Any]] = {}
    drafted_event_names: Set[str] = set()

    for event in _sort_dict_entries(transition_events):
        transition_id = str(event.get("transition_id", ""))
        if not transition_id:
            continue
        event_name = _pascal_case(str(event.get("name", "TransitionEvent")))
        object_entry = object_by_id.get(str(event.get("object_id", "")), {})
        pk_props = {
            _camel_case(str(field.get("name", "id")))
            for field in _object_primary_key_fields(object_entry)
        }
        implicit_props: List[str] = []
        for field_entry in [item for item in event.get("fields", []) if isinstance(item, dict)]:
            prop_name = _camel_case(str(field_entry.get("name", "field")))
            if prop_name in pk_props or prop_name in {"fromState", "toState"}:
                if prop_name not in implicit_props:
                    implicit_props.append(prop_name)
        if "fromState" not in implicit_props:
            implicit_props.append("fromState")
        if "toState" not in implicit_props:
            implicit_props.append("toState")
        event_metadata_by_transition_id[transition_id] = {
            "event_name": event_name,
            "implicit_props": implicit_props,
        }

        if event_name in drafted_event_names:
            continue
        drafted_event_names.add(event_name)
        draft_name = f"{event_name}Draft"
        lines.append("@dataclass")
        lines.append(f"class {draft_name}:")
        lines.append("    _seed: Dict[str, object]")
        lines.append("    _fields: Dict[str, object] = field(default_factory=dict)")
        lines.append("")
        lines.append(f"    def with_fields(self, **fields: object) -> '{draft_name}':")
        lines.append("        self._fields.update(fields)")
        lines.append("        return self")
        lines.append("")
        lines.append(f"    def build(self, **fields: object) -> {event_name}:")
        lines.append("        payload = dict(self._seed)")
        lines.append("        payload.update(self._fields)")
        lines.append("        payload.update(fields)")
        lines.append(f"        return {event_name}(**payload)")
        lines.append("")

    object_handler_specs: List[Dict[str, str]] = []
    for obj, transitions in transition_objects:
        object_name = _pascal_case(str(obj.get("name", "Object")))
        object_prop = _camel_case(object_name)
        pk_fields = _object_primary_key_fields(obj)
        state_by_id = {
            str(state.get("id", "")): str(state.get("name", ""))
            for state in obj.get("states", [])
            if isinstance(state, dict)
        }
        ref_or_object = f"{object_name}RefOrObject"
        handler_name = f"{object_name}TransitionHandler"
        service_name = f"{object_name}TransitionService"
        validator_name = f"{object_name}TransitionValidator"
        validator_default_name = f"{object_name}TransitionValidatorDefault"

        lines.append(f"{ref_or_object} = Union[{object_name}Ref, {object_name}]")
        lines.append("")
        lines.append(f"class {handler_name}(Protocol):")
        method_specs: List[Dict[str, Any]] = []
        for transition in transitions:
            transition_id = str(transition.get("id", ""))
            transition_name = str(transition.get("name", "transition"))
            method_name = _camel_case(f"{transition_name}_{object_name}")
            event_meta = event_metadata_by_transition_id.get(transition_id, {})
            event_name = str(event_meta.get("event_name", "TransitionEvent"))
            draft_name = f"{event_name}Draft"
            if async_mode:
                lines.append(f"    async def {method_name}(self, target: {ref_or_object}) -> {draft_name}: ...")
            else:
                lines.append(f"    def {method_name}(self, target: {ref_or_object}) -> {draft_name}: ...")
            method_specs.append(
                {
                    "transition_id": transition_id,
                    "transition_name": transition_name,
                    "method_name": method_name,
                    "event_name": event_name,
                    "draft_name": draft_name,
                    "implicit_props": list(event_meta.get("implicit_props", [])),
                    "from_state": state_by_id.get(str(transition.get("from_state_id", "")), ""),
                    "to_state": state_by_id.get(str(transition.get("to_state_id", "")), ""),
                }
            )
        lines.append("")

        lines.append(f"class {validator_name}(Protocol):")
        for method in method_specs:
            validator_method = f"validate{_pascal_case(str(method['method_name']))}"
            if async_mode:
                lines.append(f"    async def {validator_method}(self, target: {object_name}) -> TransitionValidationResult: ...")
            else:
                lines.append(f"    def {validator_method}(self, target: {object_name}) -> TransitionValidationResult: ...")
        lines.append("")

        lines.append(f"class {validator_default_name}:")
        for method in method_specs:
            validator_method = f"validate{_pascal_case(str(method['method_name']))}"
            if async_mode:
                lines.append(f"    async def {validator_method}(self, _target: {object_name}) -> TransitionValidationResult:")
            else:
                lines.append(f"    def {validator_method}(self, _target: {object_name}) -> TransitionValidationResult:")
            lines.append("        return TransitionValidationResult(passesValidation=True)")
            lines.append("")

        lines.append(f"class {handler_name}Default:")
        lines.append(
            f"    def __init__(self, repository: {object_name}Repository, validator: Optional[{validator_name}] = None):"
        )
        lines.append("        self._repository = repository")
        lines.append(f"        self._validator = validator if validator is not None else {validator_default_name}()")
        lines.append("")
        for method in method_specs:
            method_name = str(method["method_name"])
            draft_name = str(method["draft_name"])
            transition_name = str(method["transition_name"])
            transition_id = str(method["transition_id"])
            from_state = str(method["from_state"])
            to_state = str(method["to_state"])
            implicit_props = [str(item) for item in method.get("implicit_props", [])]
            if async_mode:
                lines.append(f"    async def {method_name}(self, target: {ref_or_object}) -> {draft_name}:")
            else:
                lines.append(f"    def {method_name}(self, target: {ref_or_object}) -> {draft_name}:")
            lines.append(f"        id = {object_name}Ref(")
            for pk_field in pk_fields:
                pk_prop = _camel_case(str(pk_field.get("name", "id")))
                lines.append(f"            {pk_prop}=target.{pk_prop},")
            lines.append("        )")
            if async_mode:
                lines.append("        current = await self._repository.get_by_id(id)")
            else:
                lines.append("        current = self._repository.get_by_id(id)")
            lines.append("        if current is None:")
            lines.append(
                f"            raise RuntimeError(\"{object_name} not found for transition '{transition_name}'\")"
            )
            validator_method = f"validate{_pascal_case(method_name)}"
            if async_mode:
                lines.append(f"        validation = await self._validator.{validator_method}(current)")
            else:
                lines.append(f"        validation = self._validator.{validator_method}(current)")
            lines.append("        if not validation.passesValidation:")
            lines.append(
                f"            raise RuntimeError(validation.failureReason or \"Transition validation failed for {object_name}.{transition_name}\")"
            )
            if async_mode:
                lines.append(
                    f"        transitioned = await self._repository.apply_transition(id, '{from_state}', '{to_state}', '{transition_id}')"
                )
            else:
                lines.append(
                    f"        transitioned = self._repository.apply_transition(id, '{from_state}', '{to_state}', '{transition_id}')"
                )
            lines.append("        if transitioned is None:")
            if async_mode:
                lines.append("            latest = await self._repository.get_by_id(id)")
            else:
                lines.append("            latest = self._repository.get_by_id(id)")
            lines.append("            if latest is None:")
            lines.append(
                f"                raise RuntimeError(\"{object_name} not found for transition '{transition_name}'\")"
            )
            lines.append(
                f"            raise RuntimeError(f\"Invalid state transition {object_name}.{transition_name}: expected {from_state} but was {{latest.state}}\")"
            )
            lines.append("        seed: Dict[str, object] = {}")
            for prop_name in implicit_props:
                if prop_name == "fromState":
                    lines.append(f"        seed['fromState'] = '{from_state}'")
                elif prop_name == "toState":
                    lines.append(f"        seed['toState'] = '{to_state}'")
                else:
                    lines.append(f"        seed['{prop_name}'] = transitioned.{prop_name}")
            lines.append(f"        return {draft_name}(_seed=seed)")
            lines.append("")

        lines.append(f"class {service_name}({handler_name}, Protocol):")
        lines.append("    pass")
        lines.append("")
        lines.append(f"class {service_name}Default:")
        lines.append(
            f"    def __init__(self, repositories: Repositories, handler: Optional[{handler_name}] = None, validator: Optional[{validator_name}] = None):"
        )
        lines.append(
            f"        self._delegate = handler if handler is not None else {handler_name}Default(repositories.{object_prop}, validator)"
        )
        lines.append("")
        for method in method_specs:
            method_name = str(method["method_name"])
            draft_name = str(method["draft_name"])
            if async_mode:
                lines.append(f"    async def {method_name}(self, target: {ref_or_object}) -> {draft_name}:")
                lines.append(f"        return await self._delegate.{method_name}(target)")
            else:
                lines.append(f"    def {method_name}(self, target: {ref_or_object}) -> {draft_name}:")
                lines.append(f"        return self._delegate.{method_name}(target)")
            lines.append("")

        object_handler_specs.append(
            {
                "object_name": object_name,
                "object_prop": object_prop,
                "handler_name": handler_name,
                "service_name": service_name,
                "validator_name": validator_name,
            }
        )

    lines.append("class TransitionHandlers(Protocol):")
    for spec in object_handler_specs:
        lines.append(f"    {spec['object_prop']}: Optional[{spec['handler_name']}]")
    lines.append("")
    lines.append("class TransitionValidators(Protocol):")
    for spec in object_handler_specs:
        lines.append(f"    {spec['object_prop']}: Optional[{spec['validator_name']}]")
    lines.append("")
    lines.append("class TransitionServices:")
    lines.append(
        "    def __init__(self, repositories: Repositories, handlers: Optional[TransitionHandlers] = None, validators: Optional[TransitionValidators] = None):"
    )
    for spec in object_handler_specs:
        lines.append(
            f"        self.{spec['object_prop']} = {spec['service_name']}Default("
            + "repositories, "
            + f"getattr(handlers, '{spec['object_prop']}', None) if handlers is not None else None, "
            + f"getattr(validators, '{spec['object_prop']}', None) if validators is not None else None)"
        )
    lines.append("")

    return "\n".join(lines).rstrip() + "\n"
