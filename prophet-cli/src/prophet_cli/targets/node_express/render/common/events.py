from __future__ import annotations

from typing import Any, Dict, List

from ..support import _pascal_case

def _render_event_emitter(ir: Dict[str, Any]) -> str:
    output_by_id = {item["id"]: item for item in ir.get("action_outputs", []) if isinstance(item, dict) and "id" in item}
    schema_version = str(ir.get("ontology", {}).get("version", "1.0.0"))

    domain_variants: List[str] = []
    constructor_lines: List[str] = []
    switch_lines: List[str] = []
    unique_events: List[Dict[str, str]] = []
    seen_event_names: set[str] = set()

    for event in sorted(ir.get("events", []), key=lambda item: str(item.get("id", ""))):
        if not isinstance(event, dict):
            continue
        kind = str(event.get("kind", ""))
        if kind not in {"action_output", "signal"}:
            continue
        event_name = _pascal_case(str(event.get("name", "Event")))
        if event_name in seen_event_names:
            continue
        seen_event_names.add(event_name)
        if kind == "action_output":
            shape_id = str(event.get("output_shape_id", ""))
            payload_type = f"Actions.{_pascal_case(str(output_by_id.get(shape_id, {}).get('name', event_name)))}"
        else:
            payload_type = f"EventContracts.{event_name}"
        unique_events.append({"event_name": event_name, "payload_type": payload_type})

    for item in unique_events:
        event_name = item["event_name"]
        payload_type = item["payload_type"]
        domain_variants.append(f"  | {{ type: '{event_name}'; payload: {payload_type} }}")
        constructor_name = f"create{event_name}Event"
        constructor_lines.extend(
            [
                f"export function {constructor_name}(payload: {payload_type}): DomainEvent {{",
                f"  return {{ type: '{event_name}', payload }};",
                "}",
                "",
            ]
        )
        switch_lines.extend(
            [
                f"    case '{event_name}':",
                "      return {",
                "        event_id: createEventId(),",
                "        trace_id: metadata.traceId,",
                f"        event_type: '{event_name}',",
                f"        schema_version: '{schema_version}',",
                "        occurred_at: nowIso(),",
                "        source: metadata.source,",
                "        payload: event.payload as Record<string, unknown>,",
                "        attributes: metadata.attributes,",
                "      };",
            ]
        )

    lines: List[str] = [
        "// Code generated by prophet-cli. DO NOT EDIT.",
        "",
        "import type * as Actions from './actions';",
        "import type * as EventContracts from './event-contracts';",
        "import { createEventId, nowIso, NoOpEventPublisher, type EventPublisher, type EventWireEnvelope } from '@prophet/events-runtime';",
        "",
    ]

    if domain_variants:
        lines.append("export type DomainEvent =")
        lines.extend(domain_variants)
        lines.append("")
    else:
        lines.append("export type DomainEvent = never;")
        lines.append("")

    lines.extend(
        [
            "export interface ActionOutcome<TOutput> {",
            "  output: TOutput;",
            "  additionalEvents: DomainEvent[];",
            "}",
            "",
            "export type ActionOutcomeValue<TOutput> = TOutput | ActionOutcome<TOutput>;",
            "",
            "export interface EventPublishMetadata {",
            "  traceId: string;",
            "  source: string;",
            "  attributes?: Record<string, string>;",
            "}",
            "",
            "export function just<TOutput>(output: TOutput): ActionOutcome<TOutput> {",
            "  return { output, additionalEvents: [] };",
            "}",
            "",
            "export function withEvents<TOutput>(output: TOutput, ...additionalEvents: DomainEvent[]): ActionOutcome<TOutput> {",
            "  return { output, additionalEvents };",
            "}",
            "",
            "export function toActionOutcome<TOutput>(value: ActionOutcomeValue<TOutput>): ActionOutcome<TOutput> {",
            "  if (value && typeof value === 'object' && 'output' in value && 'additionalEvents' in value) {",
            "    return value as ActionOutcome<TOutput>;",
            "  }",
            "  return just(value as TOutput);",
            "}",
            "",
        ]
    )

    lines.extend(constructor_lines)

    lines.extend(
        [
            "function toEventWireEnvelope(event: DomainEvent, metadata: EventPublishMetadata): EventWireEnvelope {",
            "  switch (event.type) {",
        ]
    )
    lines.extend(switch_lines)
    lines.extend(
        [
            "    default:",
            "      throw new Error(`Unsupported domain event: ${(event as { type?: string }).type ?? 'unknown'}`);",
            "  }",
            "}",
            "",
            "export async function publishDomainEvents(",
            "  eventPublisher: EventPublisher,",
            "  events: DomainEvent[],",
            "  metadata: EventPublishMetadata,",
            "): Promise<void> {",
            "  if (!events.length) {",
            "    return;",
            "  }",
            "  const envelopes = events.map((event) => toEventWireEnvelope(event, metadata));",
            "  await eventPublisher.publishBatch(envelopes);",
            "}",
            "",
            "export { EventPublisher, EventWireEnvelope, NoOpEventPublisher };",
            "",
        ]
    )

    return "\n".join(lines).rstrip() + "\n"
