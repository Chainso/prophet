from __future__ import annotations

from typing import Any, Dict, List, Set

from ..support import _camel_case
from ..support import _object_primary_key_fields
from ..support import _pascal_case


def _render_transition_services(ir: Dict[str, Any]) -> str:
    objects = [item for item in ir.get("objects", []) if isinstance(item, dict)]
    object_by_id = {str(item.get("id", "")): item for item in objects}
    transition_events = [
        item
        for item in ir.get("events", [])
        if isinstance(item, dict) and str(item.get("kind", "")) == "transition"
    ]
    event_by_transition_id = {
        str(item.get("transition_id", "")): item
        for item in transition_events
        if str(item.get("transition_id", ""))
    }

    lines: List[str] = [
        "// Code generated by prophet-cli. DO NOT EDIT.",
        "",
        "import { TransitionValidationResult } from '@prophet-ontology/events-runtime';",
        "import type * as Domain from './domain';",
        "import type * as EventContracts from './event-contracts';",
        "import type * as Persistence from './persistence';",
        "",
    ]

    transition_objects = []
    for obj in sorted(objects, key=lambda item: str(item.get("id", ""))):
        transitions = [
            item
            for item in sorted(obj.get("transitions", []), key=lambda item: str(item.get("id", "")))
            if isinstance(item, dict) and str(item.get("id", "")) in event_by_transition_id
        ]
        if transitions:
            transition_objects.append((obj, transitions))

    if not transition_objects:
        lines.append("export interface TransitionHandlers {}")
        lines.append("")
        lines.append("export class TransitionServices {")
        lines.append("  constructor(_repositories: Persistence.Repositories, _handlers: TransitionHandlers = {}) {}")
        lines.append("}")
        lines.append("")
        return "\n".join(lines).rstrip() + "\n"

    event_metadata_by_transition_id: Dict[str, Dict[str, Any]] = {}
    drafted_event_names: Set[str] = set()

    for event in sorted(transition_events, key=lambda item: str(item.get("id", ""))):
        transition_id = str(event.get("transition_id", ""))
        if not transition_id:
            continue
        event_name = _pascal_case(str(event.get("name", "TransitionEvent")))
        object_entry = object_by_id.get(str(event.get("object_id", "")), {})
        pk_props = {
            _camel_case(str(field.get("name", "id")))
            for field in _object_primary_key_fields(object_entry)
        }
        implicit_props: List[str] = []
        for field in [item for item in event.get("fields", []) if isinstance(item, dict)]:
            prop_name = _camel_case(str(field.get("name", "field")))
            if prop_name in pk_props or prop_name in {"fromState", "toState"}:
                if prop_name not in implicit_props:
                    implicit_props.append(prop_name)
        if "fromState" not in implicit_props:
            implicit_props.append("fromState")
        if "toState" not in implicit_props:
            implicit_props.append("toState")

        event_metadata_by_transition_id[transition_id] = {
            "event_name": event_name,
            "implicit_props": implicit_props,
        }

        if event_name in drafted_event_names:
            continue
        drafted_event_names.add(event_name)

        pick_union = " | ".join([f"'{prop}'" for prop in implicit_props]) if implicit_props else "never"
        draft_fields_type = f"{event_name}DraftFields"
        lines.append(f"type {draft_fields_type} = Omit<EventContracts.{event_name}, {pick_union}>;")
        lines.append("")
        lines.append(f"export class {event_name}Draft {{")
        lines.append(f"  private fields: Partial<{draft_fields_type}> = {{}};")
        lines.append(f"  constructor(private readonly seed: Pick<EventContracts.{event_name}, {pick_union}>) {{}}")
        lines.append("")
        lines.append(f"  withFields(fields: Partial<{draft_fields_type}>): this {{")
        lines.append("    this.fields = { ...this.fields, ...fields };")
        lines.append("    return this;")
        lines.append("  }")
        lines.append("")
        lines.append(f"  build(fields?: Partial<{draft_fields_type}>): EventContracts.{event_name} {{")
        lines.append(f"    return {{ ...this.seed, ...this.fields, ...(fields ?? {{}}) }} as EventContracts.{event_name};")
        lines.append("  }")
        lines.append("}")
        lines.append("")

    object_handler_specs: List[Dict[str, Any]] = []
    for obj, transitions in transition_objects:
        object_name = _pascal_case(str(obj.get("name", "Object")))
        object_prop = _camel_case(object_name)
        pk_fields = _object_primary_key_fields(obj)
        state_by_id = {
            str(state.get("id", "")): str(state.get("name", ""))
            for state in obj.get("states", [])
            if isinstance(state, dict)
        }

        ref_or_object = f"{object_name}RefOrObject"
        handler_name = f"{object_name}TransitionHandler"
        service_name = f"{object_name}TransitionService"
        validator_name = f"{object_name}TransitionValidator"
        validator_default_name = f"{object_name}TransitionValidatorDefault"

        lines.append(f"export type {ref_or_object} = Domain.{object_name}Ref | Domain.{object_name};")
        lines.append("")
        lines.append(f"export interface {handler_name} {{")

        method_specs: List[Dict[str, Any]] = []
        for transition in transitions:
            transition_id = str(transition.get("id", ""))
            transition_name = str(transition.get("name", "transition"))
            method_name = _camel_case(f"{transition_name}_{object_name}")
            event_metadata = event_metadata_by_transition_id.get(transition_id, {})
            event_name = str(event_metadata.get("event_name", "TransitionEvent"))
            lines.append(f"  {method_name}(target: {ref_or_object}): Promise<{event_name}Draft>;")
            method_specs.append(
                {
                    "transition_id": transition_id,
                    "transition_name": transition_name,
                    "method_name": method_name,
                    "event_name": event_name,
                    "implicit_props": list(event_metadata.get("implicit_props", [])),
                    "from_state": state_by_id.get(str(transition.get("from_state_id", "")), ""),
                    "to_state": state_by_id.get(str(transition.get("to_state_id", "")), ""),
                }
            )
        lines.append("}")
        lines.append("")

        lines.append(f"export interface {validator_name} {{")
        for method in method_specs:
            validator_method = f"validate{_pascal_case(str(method['method_name']))}"
            lines.append(
                f"  {validator_method}(target: Domain.{object_name}): TransitionValidationResult | Promise<TransitionValidationResult>;"
            )
        lines.append("}")
        lines.append("")

        lines.append(f"export class {validator_default_name} implements {validator_name} {{")
        for method in method_specs:
            validator_method = f"validate{_pascal_case(str(method['method_name']))}"
            lines.append(f"  {validator_method}(_target: Domain.{object_name}): TransitionValidationResult {{")
            lines.append("    return new TransitionValidationResult(true);")
            lines.append("  }")
            lines.append("")
        lines.append("}")
        lines.append("")

        lines.append(f"export class {handler_name}Default implements {handler_name} {{")
        lines.append(
            f"  constructor(private readonly repository: Persistence.{object_name}Repository, private readonly validator: {validator_name} = new {validator_default_name}()) {{}}"
        )
        lines.append("")

        for method in method_specs:
            method_name = str(method["method_name"])
            event_name = str(method["event_name"])
            transition_id = str(method["transition_id"])
            transition_name = str(method["transition_name"])
            from_state = str(method["from_state"])
            to_state = str(method["to_state"])
            implicit_props = [str(item) for item in method.get("implicit_props", [])]
            seed_union = " | ".join([f"'{prop}'" for prop in implicit_props]) if implicit_props else "never"

            lines.append(f"  async {method_name}(target: {ref_or_object}): Promise<{event_name}Draft> {{")
            lines.append(f"    const id: Persistence.{object_name}Id = {{")
            for pk_field in pk_fields:
                pk_prop = _camel_case(str(pk_field.get("name", "id")))
                lines.append(f"      {pk_prop}: target.{pk_prop},")
            lines.append("    };")
            validator_method = f"validate{_pascal_case(method_name)}"
            lines.append("    const current = await this.repository.getById(id);")
            lines.append("    if (!current) {")
            lines.append(f"      throw new Error(\"{object_name} not found for transition '{transition_name}'\");")
            lines.append("    }")
            lines.append(f"    const validation = await this.validator.{validator_method}(current);")
            lines.append("    if (!validation.passesValidation) {")
            lines.append(
                f"      throw new Error(validation.failureReason ?? \"Transition validation failed for {object_name}.{transition_name}\");"
            )
            lines.append("    }")
            lines.append(
                f"    const transitioned = await this.repository.applyTransition(id, '{from_state}', '{to_state}', '{transition_id}');"
            )
            lines.append("    if (!transitioned) {")
            lines.append("      const latest = await this.repository.getById(id);")
            lines.append("      if (!latest) {")
            lines.append(f"        throw new Error(\"{object_name} not found for transition '{transition_name}'\");")
            lines.append("      }")
            lines.append(
                f"      throw new Error(`Invalid state transition {object_name}.{transition_name}: expected {from_state} but was ${'{'}latest.state{'}'}`);"
            )
            lines.append("    }")
            lines.append(f"    const seed: Pick<EventContracts.{event_name}, {seed_union}> = {{")
            for prop_name in implicit_props:
                if prop_name == "fromState":
                    lines.append(f"      fromState: '{from_state}',")
                elif prop_name == "toState":
                    lines.append(f"      toState: '{to_state}',")
                else:
                    lines.append(f"      {prop_name}: transitioned.{prop_name},")
            lines.append("    };")
            lines.append(f"    return new {event_name}Draft(seed);")
            lines.append("  }")
            lines.append("")

        lines.append("}")
        lines.append("")

        lines.append(f"export interface {service_name} extends {handler_name} {{}}")
        lines.append("")
        lines.append(f"export class {service_name}Default implements {service_name} {{")
        lines.append(f"  private readonly delegate: {handler_name};")
        lines.append("")
        lines.append(
            f"  constructor(repositories: Persistence.Repositories, handler?: {handler_name}, validator?: {validator_name}) {{"
        )
        lines.append(
            f"    this.delegate = handler ?? new {handler_name}Default(repositories.{object_prop}, validator ?? new {validator_default_name}());"
        )
        lines.append("  }")
        lines.append("")
        for method in method_specs:
            method_name = str(method["method_name"])
            event_name = str(method["event_name"])
            lines.append(f"  async {method_name}(target: {ref_or_object}): Promise<{event_name}Draft> {{")
            lines.append(f"    return this.delegate.{method_name}(target);")
            lines.append("  }")
            lines.append("")
        lines.append("}")
        lines.append("")

        object_handler_specs.append(
            {
                "object_name": object_name,
                "object_prop": object_prop,
                "handler_name": handler_name,
                "service_name": service_name,
                "validator_name": validator_name,
            }
        )

    lines.append("export interface TransitionHandlers {")
    for spec in object_handler_specs:
        lines.append(f"  {spec['object_prop']}?: {spec['handler_name']};")
    lines.append("}")
    lines.append("")
    lines.append("export interface TransitionValidators {")
    for spec in object_handler_specs:
        lines.append(f"  {spec['object_prop']}?: {spec['validator_name']};")
    lines.append("}")
    lines.append("")

    lines.append("export class TransitionServices {")
    for spec in object_handler_specs:
        lines.append(f"  {spec['object_prop']}: {spec['service_name']};")
    lines.append("")
    lines.append(
        "  constructor(repositories: Persistence.Repositories, handlers: TransitionHandlers = {}, validators: TransitionValidators = {}) {"
    )
    for spec in object_handler_specs:
        lines.append(
            f"    this.{spec['object_prop']} = new {spec['service_name']}Default(repositories, handlers.{spec['object_prop']}, validators.{spec['object_prop']});"
        )
    lines.append("  }")
    lines.append("}")
    lines.append("")

    return "\n".join(lines).rstrip() + "\n"
