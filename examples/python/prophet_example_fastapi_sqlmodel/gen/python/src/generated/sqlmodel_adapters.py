# Code generated by prophet-cli. DO NOT EDIT.
from __future__ import annotations

import asyncio
import dataclasses

from typing import Callable, Optional

from sqlalchemy import func, update
from sqlmodel import Session, select

from . import domain as Domain
from . import persistence as Persistence
from . import query as Filters
from . import sqlmodel_models as Models

def _serialize(value):
    if dataclasses.is_dataclass(value):
        return dataclasses.asdict(value)
    if isinstance(value, list):
        return [_serialize(item) for item in value]
    return value

def _order_to_model(item: Domain.Order) -> Models.OrderModel:
    return Models.OrderModel(
        orderId=_serialize(item.orderId),
        customer=_serialize(item.customer),
        totalAmount=_serialize(item.totalAmount),
        discountCode=_serialize(item.discountCode),
        tags=_serialize(item.tags),
        shippingAddress=_serialize(item.shippingAddress),
        approvedByUserId=_serialize(item.approvedByUserId),
        approvalNotes=_serialize(item.approvalNotes),
        approvalReason=_serialize(item.approvalReason),
        shippingCarrier=_serialize(item.shippingCarrier),
        shippingTrackingNumber=_serialize(item.shippingTrackingNumber),
        shippingPackageIds=_serialize(item.shippingPackageIds),
        state=item.state,
    )

def _order_to_domain(record: Models.OrderModel) -> Domain.Order:
    return Domain.Order(
        orderId=record.orderId,
        customer=Domain.UserRef(**record.customer) if isinstance(record.customer, dict) else record.customer,
        totalAmount=record.totalAmount,
        discountCode=record.discountCode,
        tags=record.tags,
        shippingAddress=Domain.Address(**record.shippingAddress) if isinstance(record.shippingAddress, dict) else record.shippingAddress,
        approvedByUserId=record.approvedByUserId,
        approvalNotes=record.approvalNotes,
        approvalReason=record.approvalReason,
        shippingCarrier=record.shippingCarrier,
        shippingTrackingNumber=record.shippingTrackingNumber,
        shippingPackageIds=record.shippingPackageIds,
        state=record.state,
    )

class OrderSqlModelRepository:
    def __init__(self, session_factory: Callable[[], Session]):
        self._session_factory = session_factory

    def _apply_filter(self, stmt, filter: Filters.OrderQueryFilter):
        if filter.approvalReason is not None:
            if filter.approvalReason.eq is not None:
                stmt = stmt.where(Models.OrderModel.approvalReason == filter.approvalReason.eq)
            if getattr(filter.approvalReason, 'inValues', None):
                stmt = stmt.where(Models.OrderModel.approvalReason.in_(filter.approvalReason.inValues))
            if getattr(filter.approvalReason, 'contains', None):
                stmt = stmt.where(Models.OrderModel.approvalReason.contains(filter.approvalReason.contains))
            if getattr(filter.approvalReason, 'gte', None) is not None:
                stmt = stmt.where(Models.OrderModel.approvalReason >= filter.approvalReason.gte)
            if getattr(filter.approvalReason, 'lte', None) is not None:
                stmt = stmt.where(Models.OrderModel.approvalReason <= filter.approvalReason.lte)
        if filter.approvedByUserId is not None:
            if filter.approvedByUserId.eq is not None:
                stmt = stmt.where(Models.OrderModel.approvedByUserId == filter.approvedByUserId.eq)
            if getattr(filter.approvedByUserId, 'inValues', None):
                stmt = stmt.where(Models.OrderModel.approvedByUserId.in_(filter.approvedByUserId.inValues))
            if getattr(filter.approvedByUserId, 'contains', None):
                stmt = stmt.where(Models.OrderModel.approvedByUserId.contains(filter.approvedByUserId.contains))
            if getattr(filter.approvedByUserId, 'gte', None) is not None:
                stmt = stmt.where(Models.OrderModel.approvedByUserId >= filter.approvedByUserId.gte)
            if getattr(filter.approvedByUserId, 'lte', None) is not None:
                stmt = stmt.where(Models.OrderModel.approvedByUserId <= filter.approvedByUserId.lte)
        if filter.customer is not None:
            if filter.customer.eq is not None:
                stmt = stmt.where(Models.OrderModel.customer == filter.customer.eq)
            if getattr(filter.customer, 'inValues', None):
                stmt = stmt.where(Models.OrderModel.customer.in_(filter.customer.inValues))
            if getattr(filter.customer, 'contains', None):
                stmt = stmt.where(Models.OrderModel.customer.contains(filter.customer.contains))
            if getattr(filter.customer, 'gte', None) is not None:
                stmt = stmt.where(Models.OrderModel.customer >= filter.customer.gte)
            if getattr(filter.customer, 'lte', None) is not None:
                stmt = stmt.where(Models.OrderModel.customer <= filter.customer.lte)
        if filter.discountCode is not None:
            if filter.discountCode.eq is not None:
                stmt = stmt.where(Models.OrderModel.discountCode == filter.discountCode.eq)
            if getattr(filter.discountCode, 'inValues', None):
                stmt = stmt.where(Models.OrderModel.discountCode.in_(filter.discountCode.inValues))
            if getattr(filter.discountCode, 'contains', None):
                stmt = stmt.where(Models.OrderModel.discountCode.contains(filter.discountCode.contains))
            if getattr(filter.discountCode, 'gte', None) is not None:
                stmt = stmt.where(Models.OrderModel.discountCode >= filter.discountCode.gte)
            if getattr(filter.discountCode, 'lte', None) is not None:
                stmt = stmt.where(Models.OrderModel.discountCode <= filter.discountCode.lte)
        if filter.orderId is not None:
            if filter.orderId.eq is not None:
                stmt = stmt.where(Models.OrderModel.orderId == filter.orderId.eq)
            if getattr(filter.orderId, 'inValues', None):
                stmt = stmt.where(Models.OrderModel.orderId.in_(filter.orderId.inValues))
            if getattr(filter.orderId, 'contains', None):
                stmt = stmt.where(Models.OrderModel.orderId.contains(filter.orderId.contains))
            if getattr(filter.orderId, 'gte', None) is not None:
                stmt = stmt.where(Models.OrderModel.orderId >= filter.orderId.gte)
            if getattr(filter.orderId, 'lte', None) is not None:
                stmt = stmt.where(Models.OrderModel.orderId <= filter.orderId.lte)
        if filter.shippingCarrier is not None:
            if filter.shippingCarrier.eq is not None:
                stmt = stmt.where(Models.OrderModel.shippingCarrier == filter.shippingCarrier.eq)
            if getattr(filter.shippingCarrier, 'inValues', None):
                stmt = stmt.where(Models.OrderModel.shippingCarrier.in_(filter.shippingCarrier.inValues))
            if getattr(filter.shippingCarrier, 'contains', None):
                stmt = stmt.where(Models.OrderModel.shippingCarrier.contains(filter.shippingCarrier.contains))
            if getattr(filter.shippingCarrier, 'gte', None) is not None:
                stmt = stmt.where(Models.OrderModel.shippingCarrier >= filter.shippingCarrier.gte)
            if getattr(filter.shippingCarrier, 'lte', None) is not None:
                stmt = stmt.where(Models.OrderModel.shippingCarrier <= filter.shippingCarrier.lte)
        if filter.shippingTrackingNumber is not None:
            if filter.shippingTrackingNumber.eq is not None:
                stmt = stmt.where(Models.OrderModel.shippingTrackingNumber == filter.shippingTrackingNumber.eq)
            if getattr(filter.shippingTrackingNumber, 'inValues', None):
                stmt = stmt.where(Models.OrderModel.shippingTrackingNumber.in_(filter.shippingTrackingNumber.inValues))
            if getattr(filter.shippingTrackingNumber, 'contains', None):
                stmt = stmt.where(Models.OrderModel.shippingTrackingNumber.contains(filter.shippingTrackingNumber.contains))
            if getattr(filter.shippingTrackingNumber, 'gte', None) is not None:
                stmt = stmt.where(Models.OrderModel.shippingTrackingNumber >= filter.shippingTrackingNumber.gte)
            if getattr(filter.shippingTrackingNumber, 'lte', None) is not None:
                stmt = stmt.where(Models.OrderModel.shippingTrackingNumber <= filter.shippingTrackingNumber.lte)
        if filter.state is not None:
            if filter.state.eq is not None:
                stmt = stmt.where(Models.OrderModel.state == filter.state.eq)
            if getattr(filter.state, 'inValues', None):
                stmt = stmt.where(Models.OrderModel.state.in_(filter.state.inValues))
            if getattr(filter.state, 'contains', None):
                stmt = stmt.where(Models.OrderModel.state.contains(filter.state.contains))
            if getattr(filter.state, 'gte', None) is not None:
                stmt = stmt.where(Models.OrderModel.state >= filter.state.gte)
            if getattr(filter.state, 'lte', None) is not None:
                stmt = stmt.where(Models.OrderModel.state <= filter.state.lte)
        if filter.totalAmount is not None:
            if filter.totalAmount.eq is not None:
                stmt = stmt.where(Models.OrderModel.totalAmount == filter.totalAmount.eq)
            if getattr(filter.totalAmount, 'inValues', None):
                stmt = stmt.where(Models.OrderModel.totalAmount.in_(filter.totalAmount.inValues))
            if getattr(filter.totalAmount, 'contains', None):
                stmt = stmt.where(Models.OrderModel.totalAmount.contains(filter.totalAmount.contains))
            if getattr(filter.totalAmount, 'gte', None) is not None:
                stmt = stmt.where(Models.OrderModel.totalAmount >= filter.totalAmount.gte)
            if getattr(filter.totalAmount, 'lte', None) is not None:
                stmt = stmt.where(Models.OrderModel.totalAmount <= filter.totalAmount.lte)
        return stmt

    def _list_sync(self, page: int, size: int) -> Persistence.PagedResult:
        with self._session_factory() as session:
            stmt = select(Models.OrderModel)
            total_stmt = select(func.count()).select_from(Models.OrderModel)
            total = int(session.exec(total_stmt).one() or 0)
            rows = list(session.exec(stmt.offset(page * size).limit(size)))
            content = [_order_to_domain(row) for row in rows]
            total_pages = (total + size - 1) // size if size > 0 else 0
            return Persistence.PagedResult(content=content, page=page, size=size, totalElements=total, totalPages=total_pages)

    def _query_sync(self, filter: Filters.OrderQueryFilter, page: int, size: int) -> Persistence.PagedResult:
        with self._session_factory() as session:
            base_stmt = select(Models.OrderModel)
            stmt = self._apply_filter(base_stmt, filter)
            rows = list(session.exec(stmt.offset(page * size).limit(size)))
            count_stmt = self._apply_filter(select(func.count()).select_from(Models.OrderModel), filter)
            total = int(session.exec(count_stmt).one() or 0)
            content = [_order_to_domain(row) for row in rows]
            total_pages = (total + size - 1) // size if size > 0 else 0
            return Persistence.PagedResult(content=content, page=page, size=size, totalElements=total, totalPages=total_pages)

    def _get_by_id_sync(self, id: Domain.OrderRef) -> Optional[Domain.Order]:
        with self._session_factory() as session:
            stmt = select(Models.OrderModel)
            stmt = stmt.where(Models.OrderModel.orderId == id.orderId)
            record = session.exec(stmt.limit(1)).first()
            if record is None:
                return None
            return _order_to_domain(record)

    def _save_sync(self, item: Domain.Order) -> Domain.Order:
        with self._session_factory() as session:
            model = _order_to_model(item)
            session.merge(model)
            session.commit()
        return item

    def _apply_transition_sync(self, id: Domain.OrderRef, expected_state: Domain.OrderState, next_state: Domain.OrderState, transition_id: str) -> Optional[Domain.Order]:
        with self._session_factory() as session:
            stmt = update(Models.OrderModel).where(Models.OrderModel.state == expected_state)
            stmt = stmt.where(Models.OrderModel.orderId == id.orderId)
            stmt = stmt.values(state=next_state)
            result = session.exec(stmt)
            if int(getattr(result, 'rowcount', 0) or 0) < 1:
                return None
            history = Models.OrderStateHistoryModel(
                orderId=id.orderId,
                transitionId=transition_id,
                fromState=expected_state,
                toState=next_state,
            )
            session.add(history)
            session.commit()
            refreshed_stmt = select(Models.OrderModel)
            refreshed_stmt = refreshed_stmt.where(Models.OrderModel.orderId == id.orderId)
            refreshed = session.exec(refreshed_stmt.limit(1)).first()
            if refreshed is None:
                return None
            return _order_to_domain(refreshed)

    async def list(self, page: int, size: int) -> Persistence.PagedResult:
        return self._list_sync(page, size)

    async def query(self, filter: Filters.OrderQueryFilter, page: int, size: int) -> Persistence.PagedResult:
        return self._query_sync(filter, page, size)

    async def get_by_id(self, id: Domain.OrderRef) -> Optional[Domain.Order]:
        return self._get_by_id_sync(id)

    async def save(self, item: Domain.Order) -> Domain.Order:
        return self._save_sync(item)

    async def apply_transition(self, id: Domain.OrderRef, expected_state: Domain.OrderState, next_state: Domain.OrderState, transition_id: str) -> Optional[Domain.Order]:
        return self._apply_transition_sync(id, expected_state, next_state, transition_id)

def _user_to_model(item: Domain.User) -> Models.UserModel:
    return Models.UserModel(
        userId=_serialize(item.userId),
        email=_serialize(item.email),
    )

def _user_to_domain(record: Models.UserModel) -> Domain.User:
    return Domain.User(
        userId=record.userId,
        email=record.email,
    )

class UserSqlModelRepository:
    def __init__(self, session_factory: Callable[[], Session]):
        self._session_factory = session_factory

    def _apply_filter(self, stmt, filter: Filters.UserQueryFilter):
        if filter.email is not None:
            if filter.email.eq is not None:
                stmt = stmt.where(Models.UserModel.email == filter.email.eq)
            if getattr(filter.email, 'inValues', None):
                stmt = stmt.where(Models.UserModel.email.in_(filter.email.inValues))
            if getattr(filter.email, 'contains', None):
                stmt = stmt.where(Models.UserModel.email.contains(filter.email.contains))
            if getattr(filter.email, 'gte', None) is not None:
                stmt = stmt.where(Models.UserModel.email >= filter.email.gte)
            if getattr(filter.email, 'lte', None) is not None:
                stmt = stmt.where(Models.UserModel.email <= filter.email.lte)
        if filter.userId is not None:
            if filter.userId.eq is not None:
                stmt = stmt.where(Models.UserModel.userId == filter.userId.eq)
            if getattr(filter.userId, 'inValues', None):
                stmt = stmt.where(Models.UserModel.userId.in_(filter.userId.inValues))
            if getattr(filter.userId, 'contains', None):
                stmt = stmt.where(Models.UserModel.userId.contains(filter.userId.contains))
            if getattr(filter.userId, 'gte', None) is not None:
                stmt = stmt.where(Models.UserModel.userId >= filter.userId.gte)
            if getattr(filter.userId, 'lte', None) is not None:
                stmt = stmt.where(Models.UserModel.userId <= filter.userId.lte)
        return stmt

    def _list_sync(self, page: int, size: int) -> Persistence.PagedResult:
        with self._session_factory() as session:
            stmt = select(Models.UserModel)
            total_stmt = select(func.count()).select_from(Models.UserModel)
            total = int(session.exec(total_stmt).one() or 0)
            rows = list(session.exec(stmt.offset(page * size).limit(size)))
            content = [_user_to_domain(row) for row in rows]
            total_pages = (total + size - 1) // size if size > 0 else 0
            return Persistence.PagedResult(content=content, page=page, size=size, totalElements=total, totalPages=total_pages)

    def _query_sync(self, filter: Filters.UserQueryFilter, page: int, size: int) -> Persistence.PagedResult:
        with self._session_factory() as session:
            base_stmt = select(Models.UserModel)
            stmt = self._apply_filter(base_stmt, filter)
            rows = list(session.exec(stmt.offset(page * size).limit(size)))
            count_stmt = self._apply_filter(select(func.count()).select_from(Models.UserModel), filter)
            total = int(session.exec(count_stmt).one() or 0)
            content = [_user_to_domain(row) for row in rows]
            total_pages = (total + size - 1) // size if size > 0 else 0
            return Persistence.PagedResult(content=content, page=page, size=size, totalElements=total, totalPages=total_pages)

    def _get_by_id_sync(self, id: Domain.UserRef) -> Optional[Domain.User]:
        with self._session_factory() as session:
            stmt = select(Models.UserModel)
            stmt = stmt.where(Models.UserModel.userId == id.userId)
            record = session.exec(stmt.limit(1)).first()
            if record is None:
                return None
            return _user_to_domain(record)

    def _save_sync(self, item: Domain.User) -> Domain.User:
        with self._session_factory() as session:
            model = _user_to_model(item)
            session.merge(model)
            session.commit()
        return item

    async def list(self, page: int, size: int) -> Persistence.PagedResult:
        return self._list_sync(page, size)

    async def query(self, filter: Filters.UserQueryFilter, page: int, size: int) -> Persistence.PagedResult:
        return self._query_sync(filter, page, size)

    async def get_by_id(self, id: Domain.UserRef) -> Optional[Domain.User]:
        return self._get_by_id_sync(id)

    async def save(self, item: Domain.User) -> Domain.User:
        return self._save_sync(item)

class SqlModelRepositories:
    def __init__(self, session_factory: Callable[[], Session]):
        self.order = OrderSqlModelRepository(session_factory)
        self.user = UserSqlModelRepository(session_factory)
