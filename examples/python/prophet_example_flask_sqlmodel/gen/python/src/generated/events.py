# Code generated by prophet-cli. DO NOT EDIT.
from __future__ import annotations

import dataclasses

from dataclasses import dataclass
from dataclasses import field
from typing import Generic, List, Literal, Optional, Protocol, TypeVar, Union

from prophet_events_runtime import EventPublisher
from prophet_events_runtime import EventWireEnvelope
from prophet_events_runtime import NoOpEventPublisher
from prophet_events_runtime import create_event_id
from prophet_events_runtime import now_iso
from prophet_events_runtime import publish_batch_sync

from . import actions as Actions
from . import event_contracts as EventContracts

TOutput = TypeVar('TOutput')

@dataclass(kw_only=True)
class EventPublishMetadata:
    trace_id: str
    source: str
    attributes: Optional[dict[str, str]] = None

@dataclass(kw_only=True)
class ActionOutcome(Generic[TOutput]):
    output: TOutput
    additional_events: List[DomainEvent] = field(default_factory=list)

ActionOutcomeValue = Union[TOutput, ActionOutcome[TOutput]]

@dataclass(kw_only=True)
class ApproveOrderResultDomainEvent:
    type: Literal['ApproveOrderResult'] = 'ApproveOrderResult'
    payload: Actions.ApproveOrderResult

@dataclass(kw_only=True)
class CreateOrderResultDomainEvent:
    type: Literal['CreateOrderResult'] = 'CreateOrderResult'
    payload: Actions.CreateOrderResult

@dataclass(kw_only=True)
class ShipOrderResultDomainEvent:
    type: Literal['ShipOrderResult'] = 'ShipOrderResult'
    payload: Actions.ShipOrderResult

@dataclass(kw_only=True)
class PaymentCapturedDomainEvent:
    type: Literal['PaymentCaptured'] = 'PaymentCaptured'
    payload: EventContracts.PaymentCaptured

DomainEvent = Union[ApproveOrderResultDomainEvent, CreateOrderResultDomainEvent, ShipOrderResultDomainEvent, PaymentCapturedDomainEvent]

def just(output: TOutput) -> ActionOutcome[TOutput]:
    return ActionOutcome(output=output, additional_events=[])

def with_events(output: TOutput, *additional_events: DomainEvent) -> ActionOutcome[TOutput]:
    return ActionOutcome(output=output, additional_events=list(additional_events))

def to_action_outcome(value: ActionOutcomeValue[TOutput]) -> ActionOutcome[TOutput]:
    if isinstance(value, ActionOutcome):
        return value
    return just(value)

def create_approve_order_result_event(payload: Actions.ApproveOrderResult) -> ApproveOrderResultDomainEvent:
    return ApproveOrderResultDomainEvent(payload=payload)

def create_create_order_result_event(payload: Actions.CreateOrderResult) -> CreateOrderResultDomainEvent:
    return CreateOrderResultDomainEvent(payload=payload)

def create_ship_order_result_event(payload: Actions.ShipOrderResult) -> ShipOrderResultDomainEvent:
    return ShipOrderResultDomainEvent(payload=payload)

def create_payment_captured_event(payload: EventContracts.PaymentCaptured) -> PaymentCapturedDomainEvent:
    return PaymentCapturedDomainEvent(payload=payload)

def _serialize_payload(payload: object) -> dict[str, object]:
    if dataclasses.is_dataclass(payload):
        return dataclasses.asdict(payload)
    if isinstance(payload, dict):
        return payload
    return {'value': str(payload)}

def _to_event_wire_envelope(event: DomainEvent, metadata: EventPublishMetadata) -> EventWireEnvelope:
    return EventWireEnvelope(
        event_id=create_event_id(),
        trace_id=metadata.trace_id,
        event_type=getattr(event, 'type', 'unknown'),
        schema_version='1.0.0',
        occurred_at=now_iso(),
        source=metadata.source,
        payload=_serialize_payload(getattr(event, 'payload', {})),
        attributes=metadata.attributes,
    )

async def publish_domain_events(
    event_publisher: EventPublisher,
    events: List[DomainEvent],
    metadata: EventPublishMetadata,
) -> None:
    if not events:
        return None
    envelopes = [_to_event_wire_envelope(event, metadata) for event in events]
    await event_publisher.publish_batch(envelopes)

def publish_domain_events_sync(
    event_publisher: EventPublisher,
    events: List[DomainEvent],
    metadata: EventPublishMetadata,
) -> None:
    if not events:
        return None
    envelopes = [_to_event_wire_envelope(event, metadata) for event in events]
    publish_batch_sync(event_publisher, envelopes)

EventPublisherNoOp = NoOpEventPublisher
