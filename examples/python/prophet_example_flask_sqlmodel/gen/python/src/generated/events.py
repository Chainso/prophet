# Code generated by prophet-cli. DO NOT EDIT.
from __future__ import annotations

import dataclasses

from dataclasses import dataclass
from dataclasses import field
from typing import Dict, Generic, List, Literal, Optional, Protocol, TypeVar, Union

from prophet_events_runtime import EventPublisher
from prophet_events_runtime import EventWireEnvelope
from prophet_events_runtime import NoOpEventPublisher
from prophet_events_runtime import create_event_id
from prophet_events_runtime import now_iso
from prophet_events_runtime import publish_batch_sync

from . import event_contracts as EventContracts

TOutput = TypeVar('TOutput')

@dataclass(kw_only=True)
class EventPublishMetadata:
    trace_id: str
    source: str
    attributes: Optional[dict[str, str]] = None

@dataclass(kw_only=True)
class ActionOutcome(Generic[TOutput]):
    output: TOutput
    additional_events: List[DomainEvent] = field(default_factory=list)

ActionOutcomeValue = Union[TOutput, ActionOutcome[TOutput]]

@dataclass(kw_only=True)
class CreateOrderResultDomainEvent:
    type: Literal['CreateOrderResult'] = 'CreateOrderResult'
    payload: EventContracts.CreateOrderResult

@dataclass(kw_only=True)
class PaymentCapturedDomainEvent:
    type: Literal['PaymentCaptured'] = 'PaymentCaptured'
    payload: EventContracts.PaymentCaptured

@dataclass(kw_only=True)
class OrderApproveTransitionDomainEvent:
    type: Literal['OrderApproveTransition'] = 'OrderApproveTransition'
    payload: EventContracts.OrderApproveTransition

@dataclass(kw_only=True)
class OrderShipTransitionDomainEvent:
    type: Literal['OrderShipTransition'] = 'OrderShipTransition'
    payload: EventContracts.OrderShipTransition

DomainEvent = Union[CreateOrderResultDomainEvent, PaymentCapturedDomainEvent, OrderApproveTransitionDomainEvent, OrderShipTransitionDomainEvent]

@dataclass(frozen=True)
class _RefPathBinding:
    object_type: str
    path: List[str]
    primary_keys: List[str]

def just(output: TOutput) -> ActionOutcome[TOutput]:
    return ActionOutcome(output=output, additional_events=[])

def with_events(output: TOutput, *additional_events: DomainEvent) -> ActionOutcome[TOutput]:
    return ActionOutcome(output=output, additional_events=list(additional_events))

def to_action_outcome(value: ActionOutcomeValue[TOutput]) -> ActionOutcome[TOutput]:
    if isinstance(value, ActionOutcome):
        return value
    return just(value)

def create_create_order_result_event(payload: EventContracts.CreateOrderResult) -> CreateOrderResultDomainEvent:
    return CreateOrderResultDomainEvent(payload=payload)

def create_payment_captured_event(payload: EventContracts.PaymentCaptured) -> PaymentCapturedDomainEvent:
    return PaymentCapturedDomainEvent(payload=payload)

def create_order_approve_transition_event(payload: EventContracts.OrderApproveTransition) -> OrderApproveTransitionDomainEvent:
    return OrderApproveTransitionDomainEvent(payload=payload)

def create_order_ship_transition_event(payload: EventContracts.OrderShipTransition) -> OrderShipTransitionDomainEvent:
    return OrderShipTransitionDomainEvent(payload=payload)

def _serialize_payload(payload: object) -> dict[str, object]:
    if dataclasses.is_dataclass(payload):
        return dataclasses.asdict(payload)
    if isinstance(payload, dict):
        return payload
    return {'value': str(payload)}

def _clone_json_like(value: object) -> object:
    if isinstance(value, dict):
        return {str(key): _clone_json_like(item) for key, item in value.items()}
    if isinstance(value, list):
        return [_clone_json_like(item) for item in value]
    return value

def _contains_all_primary_keys(candidate: dict[str, object], primary_keys: List[str]) -> bool:
    return all(key in candidate and candidate[key] is not None for key in primary_keys)

def _is_ref_shape(candidate: dict[str, object], primary_keys: List[str]) -> bool:
    return all(key in primary_keys for key in candidate.keys())

def _normalize_ref_value(value: object, binding: _RefPathBinding, updated_objects: List[dict[str, object]]) -> object:
    if not isinstance(value, dict):
        return value
    candidate = {str(key): item for key, item in value.items()}
    if not _contains_all_primary_keys(candidate, binding.primary_keys):
        return value
    if _is_ref_shape(candidate, binding.primary_keys):
        return candidate
    object_ref: dict[str, object] = {key: candidate[key] for key in binding.primary_keys}
    updated_objects.append({
        'object_type': binding.object_type,
        'object_ref': object_ref,
        'object': candidate,
    })
    return object_ref

def _apply_binding_at_path(current: object, binding: _RefPathBinding, path_index: int, updated_objects: List[dict[str, object]]) -> None:
    if path_index >= len(binding.path):
        return
    segment = binding.path[path_index]
    if segment == '*':
        if isinstance(current, list):
            for item in current:
                _apply_binding_at_path(item, binding, path_index + 1, updated_objects)
        return
    if not isinstance(current, dict):
        return
    next_value = current.get(segment)
    if next_value is None:
        return
    if path_index == len(binding.path) - 1:
        current[segment] = _normalize_ref_value(next_value, binding, updated_objects)
        return
    _apply_binding_at_path(next_value, binding, path_index + 1, updated_objects)

def _normalize_payload_refs(payload: dict[str, object], bindings: List[_RefPathBinding]) -> List[dict[str, object]]:
    updated_objects: List[dict[str, object]] = []
    for binding in bindings:
        _apply_binding_at_path(payload, binding, 0, updated_objects)
    return updated_objects

def _to_event_wire_envelope(event: DomainEvent, metadata: EventPublishMetadata) -> EventWireEnvelope:
    ref_bindings: List[_RefPathBinding] = []
    if isinstance(event, CreateOrderResultDomainEvent):
        ref_bindings = [
            _RefPathBinding(object_type='Order', path=['order'], primary_keys=['orderId']),
        ]
    elif isinstance(event, PaymentCapturedDomainEvent):
        ref_bindings = [
            _RefPathBinding(object_type='Order', path=['order'], primary_keys=['orderId']),
        ]
    elif isinstance(event, OrderApproveTransitionDomainEvent):
        ref_bindings = []
    elif isinstance(event, OrderShipTransitionDomainEvent):
        ref_bindings = []
    payload = _serialize_payload(_clone_json_like(getattr(event, 'payload', {})))
    updated_objects = _normalize_payload_refs(payload, ref_bindings)
    return EventWireEnvelope(
        event_id=create_event_id(),
        trace_id=metadata.trace_id,
        event_type=getattr(event, 'type', 'unknown'),
        schema_version='2.0.0',
        occurred_at=now_iso(),
        source=metadata.source,
        payload=payload,
        attributes=metadata.attributes,
        updated_objects=updated_objects or None,
    )

async def publish_domain_events(
    event_publisher: EventPublisher,
    events: List[DomainEvent],
    metadata: EventPublishMetadata,
) -> None:
    if not events:
        return None
    envelopes = [_to_event_wire_envelope(event, metadata) for event in events]
    await event_publisher.publish_batch(envelopes)

def publish_domain_events_sync(
    event_publisher: EventPublisher,
    events: List[DomainEvent],
    metadata: EventPublishMetadata,
) -> None:
    if not events:
        return None
    envelopes = [_to_event_wire_envelope(event, metadata) for event in events]
    publish_batch_sync(event_publisher, envelopes)

EventPublisherNoOp = NoOpEventPublisher
