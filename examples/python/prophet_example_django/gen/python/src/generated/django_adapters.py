# Code generated by prophet-cli. DO NOT EDIT.
from __future__ import annotations

import dataclasses

from typing import Optional

from . import django_models as Models
from . import domain as Domain
from . import persistence as Persistence
from . import query as Filters

def _serialize(value):
    if dataclasses.is_dataclass(value):
        return dataclasses.asdict(value)
    if isinstance(value, list):
        return [_serialize(item) for item in value]
    return value

def _order_payload(item: Domain.Order) -> dict:
    return {
        'orderId': _serialize(item.orderId),
        'customer': _serialize(item.customer),
        'totalAmount': _serialize(item.totalAmount),
        'discountCode': _serialize(item.discountCode),
        'tags': _serialize(item.tags),
        'shippingAddress': _serialize(item.shippingAddress),
        'approvedByUserId': _serialize(item.approvedByUserId),
        'approvalNotes': _serialize(item.approvalNotes),
        'approvalReason': _serialize(item.approvalReason),
        'shippingCarrier': _serialize(item.shippingCarrier),
        'shippingTrackingNumber': _serialize(item.shippingTrackingNumber),
        'shippingPackageIds': _serialize(item.shippingPackageIds),
        'state': item.state,
    }

def _order_to_domain(record: Models.OrderModel) -> Domain.Order:
    return Domain.Order(
        orderId=record.orderId,
        customer=Domain.UserRef(**record.customer) if isinstance(record.customer, dict) else record.customer,
        totalAmount=record.totalAmount,
        discountCode=record.discountCode,
        tags=record.tags,
        shippingAddress=Domain.Address(**record.shippingAddress) if isinstance(record.shippingAddress, dict) else record.shippingAddress,
        approvedByUserId=record.approvedByUserId,
        approvalNotes=record.approvalNotes,
        approvalReason=record.approvalReason,
        shippingCarrier=record.shippingCarrier,
        shippingTrackingNumber=record.shippingTrackingNumber,
        shippingPackageIds=record.shippingPackageIds,
        state=record.state,
    )

class OrderDjangoRepository:
    _model = Models.OrderModel

    def _apply_filter(self, queryset, filter: Filters.OrderQueryFilter):
        if filter.approvalReason is not None:
            if filter.approvalReason.eq is not None:
                queryset = queryset.filter(approvalReason=filter.approvalReason.eq)
            if getattr(filter.approvalReason, 'inValues', None):
                queryset = queryset.filter(approvalReason__in=filter.approvalReason.inValues)
            if getattr(filter.approvalReason, 'contains', None):
                queryset = queryset.filter(approvalReason__icontains=filter.approvalReason.contains)
            if getattr(filter.approvalReason, 'gte', None) is not None:
                queryset = queryset.filter(approvalReason__gte=filter.approvalReason.gte)
            if getattr(filter.approvalReason, 'lte', None) is not None:
                queryset = queryset.filter(approvalReason__lte=filter.approvalReason.lte)
        if filter.approvedByUserId is not None:
            if filter.approvedByUserId.eq is not None:
                queryset = queryset.filter(approvedByUserId=filter.approvedByUserId.eq)
            if getattr(filter.approvedByUserId, 'inValues', None):
                queryset = queryset.filter(approvedByUserId__in=filter.approvedByUserId.inValues)
            if getattr(filter.approvedByUserId, 'contains', None):
                queryset = queryset.filter(approvedByUserId__icontains=filter.approvedByUserId.contains)
            if getattr(filter.approvedByUserId, 'gte', None) is not None:
                queryset = queryset.filter(approvedByUserId__gte=filter.approvedByUserId.gte)
            if getattr(filter.approvedByUserId, 'lte', None) is not None:
                queryset = queryset.filter(approvedByUserId__lte=filter.approvedByUserId.lte)
        if filter.customer is not None:
            if filter.customer.eq is not None:
                queryset = queryset.filter(customer=filter.customer.eq)
            if getattr(filter.customer, 'inValues', None):
                queryset = queryset.filter(customer__in=filter.customer.inValues)
            if getattr(filter.customer, 'contains', None):
                queryset = queryset.filter(customer__icontains=filter.customer.contains)
            if getattr(filter.customer, 'gte', None) is not None:
                queryset = queryset.filter(customer__gte=filter.customer.gte)
            if getattr(filter.customer, 'lte', None) is not None:
                queryset = queryset.filter(customer__lte=filter.customer.lte)
        if filter.discountCode is not None:
            if filter.discountCode.eq is not None:
                queryset = queryset.filter(discountCode=filter.discountCode.eq)
            if getattr(filter.discountCode, 'inValues', None):
                queryset = queryset.filter(discountCode__in=filter.discountCode.inValues)
            if getattr(filter.discountCode, 'contains', None):
                queryset = queryset.filter(discountCode__icontains=filter.discountCode.contains)
            if getattr(filter.discountCode, 'gte', None) is not None:
                queryset = queryset.filter(discountCode__gte=filter.discountCode.gte)
            if getattr(filter.discountCode, 'lte', None) is not None:
                queryset = queryset.filter(discountCode__lte=filter.discountCode.lte)
        if filter.orderId is not None:
            if filter.orderId.eq is not None:
                queryset = queryset.filter(orderId=filter.orderId.eq)
            if getattr(filter.orderId, 'inValues', None):
                queryset = queryset.filter(orderId__in=filter.orderId.inValues)
            if getattr(filter.orderId, 'contains', None):
                queryset = queryset.filter(orderId__icontains=filter.orderId.contains)
            if getattr(filter.orderId, 'gte', None) is not None:
                queryset = queryset.filter(orderId__gte=filter.orderId.gte)
            if getattr(filter.orderId, 'lte', None) is not None:
                queryset = queryset.filter(orderId__lte=filter.orderId.lte)
        if filter.shippingCarrier is not None:
            if filter.shippingCarrier.eq is not None:
                queryset = queryset.filter(shippingCarrier=filter.shippingCarrier.eq)
            if getattr(filter.shippingCarrier, 'inValues', None):
                queryset = queryset.filter(shippingCarrier__in=filter.shippingCarrier.inValues)
            if getattr(filter.shippingCarrier, 'contains', None):
                queryset = queryset.filter(shippingCarrier__icontains=filter.shippingCarrier.contains)
            if getattr(filter.shippingCarrier, 'gte', None) is not None:
                queryset = queryset.filter(shippingCarrier__gte=filter.shippingCarrier.gte)
            if getattr(filter.shippingCarrier, 'lte', None) is not None:
                queryset = queryset.filter(shippingCarrier__lte=filter.shippingCarrier.lte)
        if filter.shippingTrackingNumber is not None:
            if filter.shippingTrackingNumber.eq is not None:
                queryset = queryset.filter(shippingTrackingNumber=filter.shippingTrackingNumber.eq)
            if getattr(filter.shippingTrackingNumber, 'inValues', None):
                queryset = queryset.filter(shippingTrackingNumber__in=filter.shippingTrackingNumber.inValues)
            if getattr(filter.shippingTrackingNumber, 'contains', None):
                queryset = queryset.filter(shippingTrackingNumber__icontains=filter.shippingTrackingNumber.contains)
            if getattr(filter.shippingTrackingNumber, 'gte', None) is not None:
                queryset = queryset.filter(shippingTrackingNumber__gte=filter.shippingTrackingNumber.gte)
            if getattr(filter.shippingTrackingNumber, 'lte', None) is not None:
                queryset = queryset.filter(shippingTrackingNumber__lte=filter.shippingTrackingNumber.lte)
        if filter.state is not None:
            if filter.state.eq is not None:
                queryset = queryset.filter(state=filter.state.eq)
            if getattr(filter.state, 'inValues', None):
                queryset = queryset.filter(state__in=filter.state.inValues)
            if getattr(filter.state, 'contains', None):
                queryset = queryset.filter(state__icontains=filter.state.contains)
            if getattr(filter.state, 'gte', None) is not None:
                queryset = queryset.filter(state__gte=filter.state.gte)
            if getattr(filter.state, 'lte', None) is not None:
                queryset = queryset.filter(state__lte=filter.state.lte)
        if filter.totalAmount is not None:
            if filter.totalAmount.eq is not None:
                queryset = queryset.filter(totalAmount=filter.totalAmount.eq)
            if getattr(filter.totalAmount, 'inValues', None):
                queryset = queryset.filter(totalAmount__in=filter.totalAmount.inValues)
            if getattr(filter.totalAmount, 'contains', None):
                queryset = queryset.filter(totalAmount__icontains=filter.totalAmount.contains)
            if getattr(filter.totalAmount, 'gte', None) is not None:
                queryset = queryset.filter(totalAmount__gte=filter.totalAmount.gte)
            if getattr(filter.totalAmount, 'lte', None) is not None:
                queryset = queryset.filter(totalAmount__lte=filter.totalAmount.lte)
        return queryset

    def list(self, page: int, size: int) -> Persistence.PagedResult:
        queryset = self._model.objects.all()
        total = queryset.count()
        rows = list(queryset[page * size : page * size + size])
        content = [_order_to_domain(row) for row in rows]
        total_pages = (total + size - 1) // size if size > 0 else 0
        return Persistence.PagedResult(content=content, page=page, size=size, totalElements=total, totalPages=total_pages)

    def query(self, filter: Filters.OrderQueryFilter, page: int, size: int) -> Persistence.PagedResult:
        queryset = self._apply_filter(self._model.objects.all(), filter)
        total = queryset.count()
        rows = list(queryset[page * size : page * size + size])
        content = [_order_to_domain(row) for row in rows]
        total_pages = (total + size - 1) // size if size > 0 else 0
        return Persistence.PagedResult(content=content, page=page, size=size, totalElements=total, totalPages=total_pages)

    def get_by_id(self, id: Domain.OrderRef) -> Optional[Domain.Order]:
        lookup = {
            'orderId': id.orderId,
        }
        row = self._model.objects.filter(**lookup).first()
        if row is None:
            return None
        return _order_to_domain(row)

    def save(self, item: Domain.Order) -> Domain.Order:
        payload = _order_payload(item)
        lookup = {
            'orderId': payload['orderId'],
        }
        self._model.objects.update_or_create(defaults=payload, **lookup)
        return item

    def apply_transition(self, id: Domain.OrderRef, expected_state: Domain.OrderState, next_state: Domain.OrderState, transition_id: str) -> Optional[Domain.Order]:
        lookup = {
            'orderId': id.orderId,
        }
        updated = self._model.objects.filter(**lookup, state=expected_state).update(state=next_state)
        if int(updated or 0) < 1:
            return None
        history_payload = {
            'orderId': id.orderId,
            'transitionId': transition_id,
            'fromState': expected_state,
            'toState': next_state,
        }
        Models.OrderStateHistoryModel.objects.create(**history_payload)
        row = self._model.objects.filter(**lookup).first()
        if row is None:
            return None
        return _order_to_domain(row)

def _user_payload(item: Domain.User) -> dict:
    return {
        'userId': _serialize(item.userId),
        'email': _serialize(item.email),
    }

def _user_to_domain(record: Models.UserModel) -> Domain.User:
    return Domain.User(
        userId=record.userId,
        email=record.email,
    )

class UserDjangoRepository:
    _model = Models.UserModel

    def _apply_filter(self, queryset, filter: Filters.UserQueryFilter):
        if filter.email is not None:
            if filter.email.eq is not None:
                queryset = queryset.filter(email=filter.email.eq)
            if getattr(filter.email, 'inValues', None):
                queryset = queryset.filter(email__in=filter.email.inValues)
            if getattr(filter.email, 'contains', None):
                queryset = queryset.filter(email__icontains=filter.email.contains)
            if getattr(filter.email, 'gte', None) is not None:
                queryset = queryset.filter(email__gte=filter.email.gte)
            if getattr(filter.email, 'lte', None) is not None:
                queryset = queryset.filter(email__lte=filter.email.lte)
        if filter.userId is not None:
            if filter.userId.eq is not None:
                queryset = queryset.filter(userId=filter.userId.eq)
            if getattr(filter.userId, 'inValues', None):
                queryset = queryset.filter(userId__in=filter.userId.inValues)
            if getattr(filter.userId, 'contains', None):
                queryset = queryset.filter(userId__icontains=filter.userId.contains)
            if getattr(filter.userId, 'gte', None) is not None:
                queryset = queryset.filter(userId__gte=filter.userId.gte)
            if getattr(filter.userId, 'lte', None) is not None:
                queryset = queryset.filter(userId__lte=filter.userId.lte)
        return queryset

    def list(self, page: int, size: int) -> Persistence.PagedResult:
        queryset = self._model.objects.all()
        total = queryset.count()
        rows = list(queryset[page * size : page * size + size])
        content = [_user_to_domain(row) for row in rows]
        total_pages = (total + size - 1) // size if size > 0 else 0
        return Persistence.PagedResult(content=content, page=page, size=size, totalElements=total, totalPages=total_pages)

    def query(self, filter: Filters.UserQueryFilter, page: int, size: int) -> Persistence.PagedResult:
        queryset = self._apply_filter(self._model.objects.all(), filter)
        total = queryset.count()
        rows = list(queryset[page * size : page * size + size])
        content = [_user_to_domain(row) for row in rows]
        total_pages = (total + size - 1) // size if size > 0 else 0
        return Persistence.PagedResult(content=content, page=page, size=size, totalElements=total, totalPages=total_pages)

    def get_by_id(self, id: Domain.UserRef) -> Optional[Domain.User]:
        lookup = {
            'userId': id.userId,
        }
        row = self._model.objects.filter(**lookup).first()
        if row is None:
            return None
        return _user_to_domain(row)

    def save(self, item: Domain.User) -> Domain.User:
        payload = _user_payload(item)
        lookup = {
            'userId': payload['userId'],
        }
        self._model.objects.update_or_create(defaults=payload, **lookup)
        return item

class DjangoRepositories:
    def __init__(self):
        self.order = OrderDjangoRepository()
        self.user = UserDjangoRepository()
