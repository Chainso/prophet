// Code generated by prophet-cli. DO NOT EDIT.

import type * as Actions from './actions.js';
import type * as EventContracts from './event-contracts.js';
import { createEventId, nowIso, NoOpEventPublisher, type EventPublisher, type EventWireEnvelope } from '@prophet-ontology/events-runtime';

export type DomainEvent =
  | { type: 'ApproveOrderResult'; payload: Actions.ApproveOrderResult }
  | { type: 'CreateOrderResult'; payload: Actions.CreateOrderResult }
  | { type: 'ShipOrderResult'; payload: Actions.ShipOrderResult }
  | { type: 'PaymentCaptured'; payload: EventContracts.PaymentCaptured }

export interface ActionOutcome<TOutput> {
  output: TOutput;
  additionalEvents: DomainEvent[];
}

export type ActionOutcomeValue<TOutput> = TOutput | ActionOutcome<TOutput>;

export interface EventPublishMetadata {
  traceId: string;
  source: string;
  attributes?: Record<string, string>;
}

export function just<TOutput>(output: TOutput): ActionOutcome<TOutput> {
  return { output, additionalEvents: [] };
}

export function withEvents<TOutput>(output: TOutput, ...additionalEvents: DomainEvent[]): ActionOutcome<TOutput> {
  return { output, additionalEvents };
}

export function toActionOutcome<TOutput>(value: ActionOutcomeValue<TOutput>): ActionOutcome<TOutput> {
  if (value && typeof value === 'object' && 'output' in value && 'additionalEvents' in value) {
    return value as ActionOutcome<TOutput>;
  }
  return just(value as TOutput);
}

export function createApproveOrderResultEvent(payload: Actions.ApproveOrderResult): DomainEvent {
  return { type: 'ApproveOrderResult', payload };
}

export function createCreateOrderResultEvent(payload: Actions.CreateOrderResult): DomainEvent {
  return { type: 'CreateOrderResult', payload };
}

export function createShipOrderResultEvent(payload: Actions.ShipOrderResult): DomainEvent {
  return { type: 'ShipOrderResult', payload };
}

export function createPaymentCapturedEvent(payload: EventContracts.PaymentCaptured): DomainEvent {
  return { type: 'PaymentCaptured', payload };
}

function toEventWireEnvelope(event: DomainEvent, metadata: EventPublishMetadata): EventWireEnvelope {
  switch (event.type) {
    case 'ApproveOrderResult':
      return {
        event_id: createEventId(),
        trace_id: metadata.traceId,
        event_type: 'ApproveOrderResult',
        schema_version: '0.1.0',
        occurred_at: nowIso(),
        source: metadata.source,
        payload: event.payload as unknown as Record<string, unknown>,
        attributes: metadata.attributes,
      };
    case 'CreateOrderResult':
      return {
        event_id: createEventId(),
        trace_id: metadata.traceId,
        event_type: 'CreateOrderResult',
        schema_version: '0.1.0',
        occurred_at: nowIso(),
        source: metadata.source,
        payload: event.payload as unknown as Record<string, unknown>,
        attributes: metadata.attributes,
      };
    case 'ShipOrderResult':
      return {
        event_id: createEventId(),
        trace_id: metadata.traceId,
        event_type: 'ShipOrderResult',
        schema_version: '0.1.0',
        occurred_at: nowIso(),
        source: metadata.source,
        payload: event.payload as unknown as Record<string, unknown>,
        attributes: metadata.attributes,
      };
    case 'PaymentCaptured':
      return {
        event_id: createEventId(),
        trace_id: metadata.traceId,
        event_type: 'PaymentCaptured',
        schema_version: '0.1.0',
        occurred_at: nowIso(),
        source: metadata.source,
        payload: event.payload as unknown as Record<string, unknown>,
        attributes: metadata.attributes,
      };
    default:
      throw new Error(`Unsupported domain event: ${(event as { type?: string }).type ?? 'unknown'}`);
  }
}

export async function publishDomainEvents(
  eventPublisher: EventPublisher,
  events: DomainEvent[],
  metadata: EventPublishMetadata,
): Promise<void> {
  if (!events.length) {
    return;
  }
  const envelopes = events.map((event) => toEventWireEnvelope(event, metadata));
  await eventPublisher.publishBatch(envelopes);
}

export { EventPublisher, EventWireEnvelope, NoOpEventPublisher };
