// Code generated by prophet-cli. DO NOT EDIT.

import type { PrismaClient } from '@prisma/client';
import type * as Domain from './domain.js';
import type * as Filters from './query.js';
import type * as Persistence from './persistence.js';

function normalizePage(page: number, size: number): { page: number; size: number } {
  const normalizedPage = Number.isFinite(page) && page >= 0 ? Math.trunc(page) : 0;
  const normalizedSize = Number.isFinite(size) && size > 0 ? Math.trunc(size) : 20;
  return { page: normalizedPage, size: normalizedSize };
}

function totalPages(totalElements: number, size: number): number {
  if (size <= 0) return 0;
  return Math.ceil(totalElements / size);
}

function parseJsonValue<T>(value: unknown): T | undefined {
  if (value === null || value === undefined) return undefined;
  if (typeof value === 'string') {
    try {
      return JSON.parse(value) as T;
    } catch {
      return undefined;
    }
  }
  return value as T;
}

export class PrismaRepositories implements Persistence.Repositories {
  order: Persistence.OrderRepository;
  user: Persistence.UserRepository;

  constructor(private readonly client: PrismaClient) {
    this.order = new OrderPrismaRepository(client);
    this.user = new UserPrismaRepository(client);
  }
}

function orderWhere(filter: Filters.OrderQueryFilter | undefined): any {
  if (!filter) return {};
  const and: any[] = [];
  const approvalReasonFilter = filter.approvalReason;
  if (approvalReasonFilter?.eq !== undefined) and.push({ approval_reason: approvalReasonFilter.eq });
  if (approvalReasonFilter?.in?.length) and.push({ approval_reason: { in: approvalReasonFilter.in } });
  if (typeof approvalReasonFilter?.contains === 'string' && approvalReasonFilter.contains.length > 0) and.push({ approval_reason: { contains: approvalReasonFilter.contains } });
  const approvedByUserIdFilter = filter.approvedByUserId;
  if (approvedByUserIdFilter?.eq !== undefined) and.push({ approved_by_user_id: approvedByUserIdFilter.eq });
  if (approvedByUserIdFilter?.in?.length) and.push({ approved_by_user_id: { in: approvedByUserIdFilter.in } });
  if (typeof approvedByUserIdFilter?.contains === 'string' && approvedByUserIdFilter.contains.length > 0) and.push({ approved_by_user_id: { contains: approvedByUserIdFilter.contains } });
  const customerFilter = filter.customer;
  if (customerFilter?.eq !== undefined) {
    and.push({ customer_user_id: customerFilter.eq.userId });
  }
  if (customerFilter?.in?.length) {
    and.push({
      OR: customerFilter.in.map((entry: any) => ({
        customer_user_id: entry.userId,
      })),
    });
  }
  const discountCodeFilter = filter.discountCode;
  if (discountCodeFilter?.eq !== undefined) and.push({ discount_code: discountCodeFilter.eq });
  if (discountCodeFilter?.in?.length) and.push({ discount_code: { in: discountCodeFilter.in } });
  if (typeof discountCodeFilter?.contains === 'string' && discountCodeFilter.contains.length > 0) and.push({ discount_code: { contains: discountCodeFilter.contains } });
  const orderIdFilter = filter.orderId;
  if (orderIdFilter?.eq !== undefined) and.push({ order_id: orderIdFilter.eq });
  if (orderIdFilter?.in?.length) and.push({ order_id: { in: orderIdFilter.in } });
  if (typeof orderIdFilter?.contains === 'string' && orderIdFilter.contains.length > 0) and.push({ order_id: { contains: orderIdFilter.contains } });
  const shippingCarrierFilter = filter.shippingCarrier;
  if (shippingCarrierFilter?.eq !== undefined) and.push({ shipping_carrier: shippingCarrierFilter.eq });
  if (shippingCarrierFilter?.in?.length) and.push({ shipping_carrier: { in: shippingCarrierFilter.in } });
  if (typeof shippingCarrierFilter?.contains === 'string' && shippingCarrierFilter.contains.length > 0) and.push({ shipping_carrier: { contains: shippingCarrierFilter.contains } });
  const shippingTrackingNumberFilter = filter.shippingTrackingNumber;
  if (shippingTrackingNumberFilter?.eq !== undefined) and.push({ shipping_tracking_number: shippingTrackingNumberFilter.eq });
  if (shippingTrackingNumberFilter?.in?.length) and.push({ shipping_tracking_number: { in: shippingTrackingNumberFilter.in } });
  if (typeof shippingTrackingNumberFilter?.contains === 'string' && shippingTrackingNumberFilter.contains.length > 0) and.push({ shipping_tracking_number: { contains: shippingTrackingNumberFilter.contains } });
  const totalAmountFilter = filter.totalAmount;
  if (totalAmountFilter?.eq !== undefined) and.push({ total_amount: totalAmountFilter.eq });
  if (totalAmountFilter?.in?.length) and.push({ total_amount: { in: totalAmountFilter.in } });
  if (totalAmountFilter?.gte !== undefined) and.push({ total_amount: { gte: totalAmountFilter.gte } });
  if (totalAmountFilter?.lte !== undefined) and.push({ total_amount: { lte: totalAmountFilter.lte } });
  const stateFilter = filter.state;
  if (stateFilter?.eq !== undefined) and.push({ state: stateFilter.eq });
  if (stateFilter?.in?.length) and.push({ state: { in: stateFilter.in } });
  if (and.length === 0) return {};
  return { AND: and };
}

function orderIdFromDomain(item: Domain.Order): Persistence.OrderId {
  return {
    orderId: item.orderId,
  };
}

function orderUniqueWhere(id: Persistence.OrderId): any {
  return { order_id: id.orderId };
}

function orderPrimaryWhere(id: Persistence.OrderId): any {
  return {
    order_id: id.orderId,
  };
}

function orderRowToDomain(row: any): Domain.Order {
  return {
    orderId: row.order_id,
    customer: {
      userId: row.customer_user_id,
    },
    totalAmount: row.total_amount,
    discountCode: row.discount_code ?? undefined,
    tags: parseJsonValue(row.tags) as any,
    shippingAddress: parseJsonValue(row.shipping_address) as any,
    approvedByUserId: row.approved_by_user_id ?? undefined,
    approvalNotes: parseJsonValue(row.approval_notes) as any,
    approvalReason: row.approval_reason ?? undefined,
    shippingCarrier: row.shipping_carrier ?? undefined,
    shippingTrackingNumber: row.shipping_tracking_number ?? undefined,
    shippingPackageIds: parseJsonValue(row.shipping_package_ids) as any,
    state: row.state,
  };
}

function orderDomainToRow(item: Domain.Order): any {
  return {
    order_id: item.orderId,
    customer_user_id: item.customer.userId,
    total_amount: item.totalAmount,
    discount_code: item.discountCode ?? null,
    tags: item.tags === undefined ? null : JSON.stringify(item.tags),
    shipping_address: item.shippingAddress === undefined ? null : JSON.stringify(item.shippingAddress),
    approved_by_user_id: item.approvedByUserId ?? null,
    approval_notes: item.approvalNotes === undefined ? null : JSON.stringify(item.approvalNotes),
    approval_reason: item.approvalReason ?? null,
    shipping_carrier: item.shippingCarrier ?? null,
    shipping_tracking_number: item.shippingTrackingNumber ?? null,
    shipping_package_ids: item.shippingPackageIds === undefined ? null : JSON.stringify(item.shippingPackageIds),
    state: item.state,
  };
}

class OrderPrismaRepository implements Persistence.OrderRepository {
  private readonly delegate: any;

  constructor(private readonly client: PrismaClient) {
    this.delegate = (client as any).order;
  }

  async list(page: number, size: number): Promise<Persistence.Page<Domain.Order>> {
    const normalized = normalizePage(page, size);
    const [rows, totalElements] = await Promise.all([
      this.delegate.findMany({
        skip: normalized.page * normalized.size,
        take: normalized.size,
        orderBy: [
          { order_id: 'asc' },
        ],
      }),
      this.delegate.count(),
    ]);
    return {
      items: rows.map(orderRowToDomain),
      page: normalized.page,
      size: normalized.size,
      totalElements,
      totalPages: totalPages(totalElements, normalized.size),
    };
  }

  async getById(id: Persistence.OrderId): Promise<Domain.Order | null> {
    const row = await this.delegate.findUnique({ where: orderUniqueWhere(id) });
    return row ? orderRowToDomain(row) : null;
  }

  async query(filter: Filters.OrderQueryFilter, page: number, size: number): Promise<Persistence.Page<Domain.Order>> {
    const normalized = normalizePage(page, size);
    const where = orderWhere(filter);
    const [rows, totalElements] = await Promise.all([
      this.delegate.findMany({
        where,
        skip: normalized.page * normalized.size,
        take: normalized.size,
        orderBy: [
          { order_id: 'asc' },
        ],
      }),
      this.delegate.count({ where }),
    ]);
    return {
      items: rows.map(orderRowToDomain),
      page: normalized.page,
      size: normalized.size,
      totalElements,
      totalPages: totalPages(totalElements, normalized.size),
    };
  }

  async save(item: Domain.Order): Promise<Domain.Order> {
    const payload = orderDomainToRow(item);
    const persisted = await this.delegate.upsert({ where: orderUniqueWhere(orderIdFromDomain(item)), create: payload, update: payload });
    return orderRowToDomain(persisted);
  }

  async applyTransition(
    id: Persistence.OrderId,
    expectedState: Domain.OrderState,
    nextState: Domain.OrderState,
    transitionId: string,
  ): Promise<Domain.Order | null> {
    const primaryWhere = orderPrimaryWhere(id);
    const persisted = await this.client.$transaction(async (tx) => {
      const objDelegate = (tx as any).order;
      const updateResult = await objDelegate.updateMany({
        where: { ...primaryWhere, state: expectedState },
        data: { state: nextState },
      });
      if (!updateResult || Number(updateResult.count ?? 0) < 1) {
        return null;
      }
      const updated = await objDelegate.findUnique({ where: orderUniqueWhere(id) });
      if (!updated) {
        return null;
      }
      await (tx as any).orderStateHistory.create({
        data: {
          ...primaryWhere,
          transition_id: transitionId,
          from_state: expectedState,
          to_state: nextState,
        },
      });
      return updated;
    });
    return persisted ? orderRowToDomain(persisted) : null;
  }
}

function userWhere(filter: Filters.UserQueryFilter | undefined): any {
  if (!filter) return {};
  const and: any[] = [];
  const emailFilter = filter.email;
  if (emailFilter?.eq !== undefined) and.push({ email: emailFilter.eq });
  if (emailFilter?.in?.length) and.push({ email: { in: emailFilter.in } });
  if (typeof emailFilter?.contains === 'string' && emailFilter.contains.length > 0) and.push({ email: { contains: emailFilter.contains } });
  const userIdFilter = filter.userId;
  if (userIdFilter?.eq !== undefined) and.push({ user_id: userIdFilter.eq });
  if (userIdFilter?.in?.length) and.push({ user_id: { in: userIdFilter.in } });
  if (typeof userIdFilter?.contains === 'string' && userIdFilter.contains.length > 0) and.push({ user_id: { contains: userIdFilter.contains } });
  if (and.length === 0) return {};
  return { AND: and };
}

function userIdFromDomain(item: Domain.User): Persistence.UserId {
  return {
    userId: item.userId,
  };
}

function userUniqueWhere(id: Persistence.UserId): any {
  return { user_id: id.userId };
}

function userPrimaryWhere(id: Persistence.UserId): any {
  return {
    user_id: id.userId,
  };
}

function userRowToDomain(row: any): Domain.User {
  return {
    userId: row.user_id,
    email: row.email,
  };
}

function userDomainToRow(item: Domain.User): any {
  return {
    user_id: item.userId,
    email: item.email,
  };
}

class UserPrismaRepository implements Persistence.UserRepository {
  private readonly delegate: any;

  constructor(private readonly client: PrismaClient) {
    this.delegate = (client as any).user;
  }

  async list(page: number, size: number): Promise<Persistence.Page<Domain.User>> {
    const normalized = normalizePage(page, size);
    const [rows, totalElements] = await Promise.all([
      this.delegate.findMany({
        skip: normalized.page * normalized.size,
        take: normalized.size,
        orderBy: [
          { user_id: 'asc' },
        ],
      }),
      this.delegate.count(),
    ]);
    return {
      items: rows.map(userRowToDomain),
      page: normalized.page,
      size: normalized.size,
      totalElements,
      totalPages: totalPages(totalElements, normalized.size),
    };
  }

  async getById(id: Persistence.UserId): Promise<Domain.User | null> {
    const row = await this.delegate.findUnique({ where: userUniqueWhere(id) });
    return row ? userRowToDomain(row) : null;
  }

  async query(filter: Filters.UserQueryFilter, page: number, size: number): Promise<Persistence.Page<Domain.User>> {
    const normalized = normalizePage(page, size);
    const where = userWhere(filter);
    const [rows, totalElements] = await Promise.all([
      this.delegate.findMany({
        where,
        skip: normalized.page * normalized.size,
        take: normalized.size,
        orderBy: [
          { user_id: 'asc' },
        ],
      }),
      this.delegate.count({ where }),
    ]);
    return {
      items: rows.map(userRowToDomain),
      page: normalized.page,
      size: normalized.size,
      totalElements,
      totalPages: totalPages(totalElements, normalized.size),
    };
  }

  async save(item: Domain.User): Promise<Domain.User> {
    const payload = userDomainToRow(item);
    const persisted = await this.delegate.upsert({ where: userUniqueWhere(userIdFromDomain(item)), create: payload, update: payload });
    return userRowToDomain(persisted);
  }
}
