// Code generated by prophet-cli. DO NOT EDIT.

import { TransitionValidationResult } from '@prophet-ontology/events-runtime';
import type * as Domain from './domain.js';
import type * as EventContracts from './event-contracts.js';
import type * as Persistence from './persistence.js';

type OrderApproveTransitionDraftFields = Omit<EventContracts.OrderApproveTransition, 'orderId' | 'fromState' | 'toState'>;

export class OrderApproveTransitionDraft {
  private fields: Partial<OrderApproveTransitionDraftFields> = {};
  constructor(private readonly seed: Pick<EventContracts.OrderApproveTransition, 'orderId' | 'fromState' | 'toState'>) {}

  withFields(fields: Partial<OrderApproveTransitionDraftFields>): this {
    this.fields = { ...this.fields, ...fields };
    return this;
  }

  build(fields?: Partial<OrderApproveTransitionDraftFields>): EventContracts.OrderApproveTransition {
    return { ...this.seed, ...this.fields, ...(fields ?? {}) } as EventContracts.OrderApproveTransition;
  }
}

type OrderShipTransitionDraftFields = Omit<EventContracts.OrderShipTransition, 'orderId' | 'fromState' | 'toState'>;

export class OrderShipTransitionDraft {
  private fields: Partial<OrderShipTransitionDraftFields> = {};
  constructor(private readonly seed: Pick<EventContracts.OrderShipTransition, 'orderId' | 'fromState' | 'toState'>) {}

  withFields(fields: Partial<OrderShipTransitionDraftFields>): this {
    this.fields = { ...this.fields, ...fields };
    return this;
  }

  build(fields?: Partial<OrderShipTransitionDraftFields>): EventContracts.OrderShipTransition {
    return { ...this.seed, ...this.fields, ...(fields ?? {}) } as EventContracts.OrderShipTransition;
  }
}

export type OrderRefOrObject = Domain.OrderRef | Domain.Order;

export interface OrderTransitionHandler {
  approveOrder(target: OrderRefOrObject): Promise<OrderApproveTransitionDraft>;
  shipOrder(target: OrderRefOrObject): Promise<OrderShipTransitionDraft>;
}

export interface OrderTransitionValidator {
  validateApproveOrder(target: Domain.Order): TransitionValidationResult | Promise<TransitionValidationResult>;
  validateShipOrder(target: Domain.Order): TransitionValidationResult | Promise<TransitionValidationResult>;
}

export class OrderTransitionValidatorDefault implements OrderTransitionValidator {
  validateApproveOrder(_target: Domain.Order): TransitionValidationResult {
    return new TransitionValidationResult(true);
  }

  validateShipOrder(_target: Domain.Order): TransitionValidationResult {
    return new TransitionValidationResult(true);
  }

}

export class OrderTransitionHandlerDefault implements OrderTransitionHandler {
  constructor(private readonly repository: Persistence.OrderRepository, private readonly validator: OrderTransitionValidator = new OrderTransitionValidatorDefault()) {}

  async approveOrder(target: OrderRefOrObject): Promise<OrderApproveTransitionDraft> {
    const id: Persistence.OrderId = {
      orderId: target.orderId,
    };
    const current = await this.repository.getById(id);
    if (!current) {
      throw new Error("Order not found for transition 'approve'");
    }
    const validation = await this.validator.validateApproveOrder(current);
    if (!validation.passesValidation) {
      throw new Error(validation.failureReason ?? "Transition validation failed for Order.approve");
    }
    const transitioned = await this.repository.applyTransition(id, 'created', 'approved', 'trans_order_approve');
    if (!transitioned) {
      const latest = await this.repository.getById(id);
      if (!latest) {
        throw new Error("Order not found for transition 'approve'");
      }
      throw new Error(`Invalid state transition Order.approve: expected created but was ${latest.state}`);
    }
    const seed: Pick<EventContracts.OrderApproveTransition, 'orderId' | 'fromState' | 'toState'> = {
      orderId: transitioned.orderId,
      fromState: 'created',
      toState: 'approved',
    };
    return new OrderApproveTransitionDraft(seed);
  }

  async shipOrder(target: OrderRefOrObject): Promise<OrderShipTransitionDraft> {
    const id: Persistence.OrderId = {
      orderId: target.orderId,
    };
    const current = await this.repository.getById(id);
    if (!current) {
      throw new Error("Order not found for transition 'ship'");
    }
    const validation = await this.validator.validateShipOrder(current);
    if (!validation.passesValidation) {
      throw new Error(validation.failureReason ?? "Transition validation failed for Order.ship");
    }
    const transitioned = await this.repository.applyTransition(id, 'approved', 'shipped', 'trans_order_ship');
    if (!transitioned) {
      const latest = await this.repository.getById(id);
      if (!latest) {
        throw new Error("Order not found for transition 'ship'");
      }
      throw new Error(`Invalid state transition Order.ship: expected approved but was ${latest.state}`);
    }
    const seed: Pick<EventContracts.OrderShipTransition, 'orderId' | 'fromState' | 'toState'> = {
      orderId: transitioned.orderId,
      fromState: 'approved',
      toState: 'shipped',
    };
    return new OrderShipTransitionDraft(seed);
  }

}

export interface OrderTransitionService extends OrderTransitionHandler {}

export class OrderTransitionServiceDefault implements OrderTransitionService {
  private readonly delegate: OrderTransitionHandler;

  constructor(repositories: Persistence.Repositories, handler?: OrderTransitionHandler, validator?: OrderTransitionValidator) {
    this.delegate = handler ?? new OrderTransitionHandlerDefault(repositories.order, validator ?? new OrderTransitionValidatorDefault());
  }

  async approveOrder(target: OrderRefOrObject): Promise<OrderApproveTransitionDraft> {
    return this.delegate.approveOrder(target);
  }

  async shipOrder(target: OrderRefOrObject): Promise<OrderShipTransitionDraft> {
    return this.delegate.shipOrder(target);
  }

}

export interface TransitionHandlers {
  order?: OrderTransitionHandler;
}

export interface TransitionValidators {
  order?: OrderTransitionValidator;
}

export class TransitionServices {
  order: OrderTransitionService;

  constructor(repositories: Persistence.Repositories, handlers: TransitionHandlers = {}, validators: TransitionValidators = {}) {
    this.order = new OrderTransitionServiceDefault(repositories, handlers.order, validators.order);
  }
}
