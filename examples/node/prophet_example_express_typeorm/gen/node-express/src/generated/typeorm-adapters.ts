// Code generated by prophet-cli. DO NOT EDIT.

import { DataSource, type Repository, type SelectQueryBuilder } from 'typeorm';
import type * as Domain from './domain.js';
import type * as Filters from './query.js';
import type * as Persistence from './persistence.js';
import {
  OrderEntity,
  OrderStateHistoryEntity,
  UserEntity
} from './typeorm-entities.js';

function normalizePage(page: number, size: number): { page: number; size: number } {
  const normalizedPage = Number.isFinite(page) && page >= 0 ? Math.trunc(page) : 0;
  const normalizedSize = Number.isFinite(size) && size > 0 ? Math.trunc(size) : 20;
  return { page: normalizedPage, size: normalizedSize };
}

function totalPages(totalElements: number, size: number): number {
  if (size <= 0) return 0;
  return Math.ceil(totalElements / size);
}

export class TypeOrmRepositories implements Persistence.Repositories {
  order: Persistence.OrderRepository;
  user: Persistence.UserRepository;

  constructor(private readonly dataSource: DataSource) {
    this.order = new OrderTypeOrmRepository(dataSource);
    this.user = new UserTypeOrmRepository(dataSource);
  }
}

function orderEntityToDomain(entity: any): Domain.Order {
  return {
    orderId: entity.orderId,
    customer: {
      userId: entity.customerUserId,
    },
    totalAmount: entity.totalAmount,
    discountCode: entity.discountCode ?? undefined,
    tags: entity.tags ?? undefined,
    shippingAddress: entity.shippingAddress ?? undefined,
    approvedByUserId: entity.approvedByUserId ?? undefined,
    approvalNotes: entity.approvalNotes ?? undefined,
    approvalReason: entity.approvalReason ?? undefined,
    shippingCarrier: entity.shippingCarrier ?? undefined,
    shippingTrackingNumber: entity.shippingTrackingNumber ?? undefined,
    shippingPackageIds: entity.shippingPackageIds ?? undefined,
    state: entity.state,
  };
}

function orderDomainToEntity(item: Domain.Order): OrderEntity {
  const entity = new OrderEntity();
  entity.orderId = item.orderId;
  entity.customerUserId = item.customer.userId;
  entity.totalAmount = item.totalAmount;
  entity.discountCode = item.discountCode ?? null;
  entity.tags = item.tags ?? null;
  entity.shippingAddress = item.shippingAddress ?? null;
  entity.approvedByUserId = item.approvedByUserId ?? null;
  entity.approvalNotes = item.approvalNotes ?? null;
  entity.approvalReason = item.approvalReason ?? null;
  entity.shippingCarrier = item.shippingCarrier ?? null;
  entity.shippingTrackingNumber = item.shippingTrackingNumber ?? null;
  entity.shippingPackageIds = item.shippingPackageIds ?? null;
  entity.state = item.state;
  return entity;
}

function orderPrimaryWhere(id: Persistence.OrderId): Record<string, unknown> {
  return {
    orderId: id.orderId,
  };
}

function orderApplyFilter(qb: SelectQueryBuilder<OrderEntity>, filter: Filters.OrderQueryFilter | undefined): void {
  if (!filter) return;
  const approvalReasonFilter = filter.approvalReason;
  if (approvalReasonFilter?.eq !== undefined) qb.andWhere('record.approval_reason = :approvalReason_eq', { approvalReason_eq: approvalReasonFilter.eq });
  if (approvalReasonFilter?.in?.length) qb.andWhere('record.approval_reason IN (:...approvalReason_in)', { approvalReason_in: approvalReasonFilter.in });
  if (typeof approvalReasonFilter?.contains === 'string' && approvalReasonFilter.contains.length > 0) qb.andWhere('record.approval_reason LIKE :approvalReason_contains', { approvalReason_contains: `%${approvalReasonFilter.contains}%` });
  const approvedByUserIdFilter = filter.approvedByUserId;
  if (approvedByUserIdFilter?.eq !== undefined) qb.andWhere('record.approved_by_user_id = :approvedByUserId_eq', { approvedByUserId_eq: approvedByUserIdFilter.eq });
  if (approvedByUserIdFilter?.in?.length) qb.andWhere('record.approved_by_user_id IN (:...approvedByUserId_in)', { approvedByUserId_in: approvedByUserIdFilter.in });
  if (typeof approvedByUserIdFilter?.contains === 'string' && approvedByUserIdFilter.contains.length > 0) qb.andWhere('record.approved_by_user_id LIKE :approvedByUserId_contains', { approvedByUserId_contains: `%${approvedByUserIdFilter.contains}%` });
  const customerFilter = filter.customer;
  if (customerFilter?.eq !== undefined) {
    qb.andWhere('record.customer_user_id = :customer_eq_userId', { customer_eq_userId: customerFilter.eq.userId });
  }
  if (customerFilter?.in?.length) {
    const clauses: string[] = [];
    const params: Record<string, unknown> = {};
    customerFilter.in.forEach((entry: any, idx: number) => {
      const inner: string[] = [];
      inner.push(`record.customer_user_id = :customer_in_${idx}_userId`);
      params['customer_in_' + idx + '_userId'] = entry.userId;
      clauses.push('(' + inner.join(' AND ') + ')');
    });
    if (clauses.length > 0) qb.andWhere('(' + clauses.join(' OR ') + ')', params);
  }
  const discountCodeFilter = filter.discountCode;
  if (discountCodeFilter?.eq !== undefined) qb.andWhere('record.discount_code = :discountCode_eq', { discountCode_eq: discountCodeFilter.eq });
  if (discountCodeFilter?.in?.length) qb.andWhere('record.discount_code IN (:...discountCode_in)', { discountCode_in: discountCodeFilter.in });
  if (typeof discountCodeFilter?.contains === 'string' && discountCodeFilter.contains.length > 0) qb.andWhere('record.discount_code LIKE :discountCode_contains', { discountCode_contains: `%${discountCodeFilter.contains}%` });
  const orderIdFilter = filter.orderId;
  if (orderIdFilter?.eq !== undefined) qb.andWhere('record.order_id = :orderId_eq', { orderId_eq: orderIdFilter.eq });
  if (orderIdFilter?.in?.length) qb.andWhere('record.order_id IN (:...orderId_in)', { orderId_in: orderIdFilter.in });
  if (typeof orderIdFilter?.contains === 'string' && orderIdFilter.contains.length > 0) qb.andWhere('record.order_id LIKE :orderId_contains', { orderId_contains: `%${orderIdFilter.contains}%` });
  const shippingCarrierFilter = filter.shippingCarrier;
  if (shippingCarrierFilter?.eq !== undefined) qb.andWhere('record.shipping_carrier = :shippingCarrier_eq', { shippingCarrier_eq: shippingCarrierFilter.eq });
  if (shippingCarrierFilter?.in?.length) qb.andWhere('record.shipping_carrier IN (:...shippingCarrier_in)', { shippingCarrier_in: shippingCarrierFilter.in });
  if (typeof shippingCarrierFilter?.contains === 'string' && shippingCarrierFilter.contains.length > 0) qb.andWhere('record.shipping_carrier LIKE :shippingCarrier_contains', { shippingCarrier_contains: `%${shippingCarrierFilter.contains}%` });
  const shippingTrackingNumberFilter = filter.shippingTrackingNumber;
  if (shippingTrackingNumberFilter?.eq !== undefined) qb.andWhere('record.shipping_tracking_number = :shippingTrackingNumber_eq', { shippingTrackingNumber_eq: shippingTrackingNumberFilter.eq });
  if (shippingTrackingNumberFilter?.in?.length) qb.andWhere('record.shipping_tracking_number IN (:...shippingTrackingNumber_in)', { shippingTrackingNumber_in: shippingTrackingNumberFilter.in });
  if (typeof shippingTrackingNumberFilter?.contains === 'string' && shippingTrackingNumberFilter.contains.length > 0) qb.andWhere('record.shipping_tracking_number LIKE :shippingTrackingNumber_contains', { shippingTrackingNumber_contains: `%${shippingTrackingNumberFilter.contains}%` });
  const totalAmountFilter = filter.totalAmount;
  if (totalAmountFilter?.eq !== undefined) qb.andWhere('record.total_amount = :totalAmount_eq', { totalAmount_eq: totalAmountFilter.eq });
  if (totalAmountFilter?.in?.length) qb.andWhere('record.total_amount IN (:...totalAmount_in)', { totalAmount_in: totalAmountFilter.in });
  if (totalAmountFilter?.gte !== undefined) qb.andWhere('record.total_amount >= :totalAmount_gte', { totalAmount_gte: totalAmountFilter.gte });
  if (totalAmountFilter?.lte !== undefined) qb.andWhere('record.total_amount <= :totalAmount_lte', { totalAmount_lte: totalAmountFilter.lte });
  const stateFilter = filter.state;
  if (stateFilter?.eq !== undefined) qb.andWhere('record.__prophet_state = :state_eq', { state_eq: stateFilter.eq });
  if (stateFilter?.in?.length) qb.andWhere('record.__prophet_state IN (:...state_in)', { state_in: stateFilter.in });
}

function orderApplyOrderBy(qb: SelectQueryBuilder<OrderEntity>): void {
  qb.addOrderBy('record.order_id', 'ASC');
}

class OrderTypeOrmRepository implements Persistence.OrderRepository {
  private readonly repo: Repository<OrderEntity>;
  private readonly historyRepo: Repository<OrderStateHistoryEntity>;

  constructor(private readonly dataSource: DataSource) {
    this.repo = dataSource.getRepository(OrderEntity);
    this.historyRepo = dataSource.getRepository(OrderStateHistoryEntity);
  }

  async list(page: number, size: number): Promise<Persistence.Page<Domain.Order>> {
    const normalized = normalizePage(page, size);
    const qb = this.repo.createQueryBuilder('record');
    orderApplyOrderBy(qb);
    qb.skip(normalized.page * normalized.size).take(normalized.size);
    const [rows, totalElements] = await qb.getManyAndCount();
    return {
      items: rows.map(orderEntityToDomain),
      page: normalized.page,
      size: normalized.size,
      totalElements,
      totalPages: totalPages(totalElements, normalized.size),
    };
  }

  async getById(id: Persistence.OrderId): Promise<Domain.Order | null> {
    const row = await this.repo.findOneBy(orderPrimaryWhere(id) as any);
    return row ? orderEntityToDomain(row) : null;
  }

  async query(filter: Filters.OrderQueryFilter, page: number, size: number): Promise<Persistence.Page<Domain.Order>> {
    const normalized = normalizePage(page, size);
    const qb = this.repo.createQueryBuilder('record');
    orderApplyFilter(qb, filter);
    orderApplyOrderBy(qb);
    qb.skip(normalized.page * normalized.size).take(normalized.size);
    const [rows, totalElements] = await qb.getManyAndCount();
    return {
      items: rows.map(orderEntityToDomain),
      page: normalized.page,
      size: normalized.size,
      totalElements,
      totalPages: totalPages(totalElements, normalized.size),
    };
  }

  async save(item: Domain.Order): Promise<Domain.Order> {
    const entity = orderDomainToEntity(item);
    const saved = await this.repo.save(entity as any);
    return orderEntityToDomain(saved);
  }

  async applyTransition(
    id: Persistence.OrderId,
    expectedState: Domain.OrderState,
    nextState: Domain.OrderState,
    transitionId: string,
  ): Promise<Domain.Order | null> {
    const primaryWhere = orderPrimaryWhere(id);
    const transitionResult = await this.repo
      .createQueryBuilder()
      .update(OrderEntity)
      .set({ state: nextState as string } as any)
      .where({ ...primaryWhere, state: expectedState } as any)
      .execute();
    if (Number(transitionResult.affected ?? 0) < 1) {
      return null;
    }
    const updated = await this.repo.findOneBy(primaryWhere as any);
    if (!updated) {
      return null;
    }
    const history = this.historyRepo.create({
      ...primaryWhere,
      transitionId,
      fromState: expectedState,
      toState: nextState,
    } as any);
    await this.historyRepo.save(history as any);
    return orderEntityToDomain(updated);
  }
}

function userEntityToDomain(entity: any): Domain.User {
  return {
    userId: entity.userId,
    email: entity.email,
  };
}

function userDomainToEntity(item: Domain.User): UserEntity {
  const entity = new UserEntity();
  entity.userId = item.userId;
  entity.email = item.email;
  return entity;
}

function userPrimaryWhere(id: Persistence.UserId): Record<string, unknown> {
  return {
    userId: id.userId,
  };
}

function userApplyFilter(qb: SelectQueryBuilder<UserEntity>, filter: Filters.UserQueryFilter | undefined): void {
  if (!filter) return;
  const emailFilter = filter.email;
  if (emailFilter?.eq !== undefined) qb.andWhere('record.email = :email_eq', { email_eq: emailFilter.eq });
  if (emailFilter?.in?.length) qb.andWhere('record.email IN (:...email_in)', { email_in: emailFilter.in });
  if (typeof emailFilter?.contains === 'string' && emailFilter.contains.length > 0) qb.andWhere('record.email LIKE :email_contains', { email_contains: `%${emailFilter.contains}%` });
  const userIdFilter = filter.userId;
  if (userIdFilter?.eq !== undefined) qb.andWhere('record.user_id = :userId_eq', { userId_eq: userIdFilter.eq });
  if (userIdFilter?.in?.length) qb.andWhere('record.user_id IN (:...userId_in)', { userId_in: userIdFilter.in });
  if (typeof userIdFilter?.contains === 'string' && userIdFilter.contains.length > 0) qb.andWhere('record.user_id LIKE :userId_contains', { userId_contains: `%${userIdFilter.contains}%` });
}

function userApplyOrderBy(qb: SelectQueryBuilder<UserEntity>): void {
  qb.addOrderBy('record.user_id', 'ASC');
}

class UserTypeOrmRepository implements Persistence.UserRepository {
  private readonly repo: Repository<UserEntity>;

  constructor(private readonly dataSource: DataSource) {
    this.repo = dataSource.getRepository(UserEntity);
  }

  async list(page: number, size: number): Promise<Persistence.Page<Domain.User>> {
    const normalized = normalizePage(page, size);
    const qb = this.repo.createQueryBuilder('record');
    userApplyOrderBy(qb);
    qb.skip(normalized.page * normalized.size).take(normalized.size);
    const [rows, totalElements] = await qb.getManyAndCount();
    return {
      items: rows.map(userEntityToDomain),
      page: normalized.page,
      size: normalized.size,
      totalElements,
      totalPages: totalPages(totalElements, normalized.size),
    };
  }

  async getById(id: Persistence.UserId): Promise<Domain.User | null> {
    const row = await this.repo.findOneBy(userPrimaryWhere(id) as any);
    return row ? userEntityToDomain(row) : null;
  }

  async query(filter: Filters.UserQueryFilter, page: number, size: number): Promise<Persistence.Page<Domain.User>> {
    const normalized = normalizePage(page, size);
    const qb = this.repo.createQueryBuilder('record');
    userApplyFilter(qb, filter);
    userApplyOrderBy(qb);
    qb.skip(normalized.page * normalized.size).take(normalized.size);
    const [rows, totalElements] = await qb.getManyAndCount();
    return {
      items: rows.map(userEntityToDomain),
      page: normalized.page,
      size: normalized.size,
      totalElements,
      totalPages: totalPages(totalElements, normalized.size),
    };
  }

  async save(item: Domain.User): Promise<Domain.User> {
    const entity = userDomainToEntity(item);
    const saved = await this.repo.save(entity as any);
    return userEntityToDomain(saved);
  }
}
