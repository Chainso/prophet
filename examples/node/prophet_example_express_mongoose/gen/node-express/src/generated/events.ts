// Code generated by prophet-cli. DO NOT EDIT.

import type * as EventContracts from './event-contracts.js';
import { createEventId, nowIso, NoOpEventPublisher, type EventPublisher, type EventUpdatedObject, type EventWireEnvelope } from '@prophet-ontology/events-runtime';

export type DomainEvent =
  | { type: 'CreateOrderResult'; payload: EventContracts.CreateOrderResult }
  | { type: 'PaymentCaptured'; payload: EventContracts.PaymentCaptured }
  | { type: 'OrderApproveTransition'; payload: EventContracts.OrderApproveTransition }
  | { type: 'OrderShipTransition'; payload: EventContracts.OrderShipTransition }

interface RefPathBinding {
  objectType: string;
  path: string[];
  primaryKeys: string[];
}

function isRecord(value: unknown): value is Record<string, unknown> {
  return value !== null && typeof value === 'object' && !Array.isArray(value);
}

function cloneJsonLike(value: unknown): unknown {
  if (Array.isArray(value)) {
    return value.map((item) => cloneJsonLike(item));
  }
  if (isRecord(value)) {
    const copy: Record<string, unknown> = {};
    for (const [key, item] of Object.entries(value)) {
      copy[key] = cloneJsonLike(item);
    }
    return copy;
  }
  return value;
}

function containsAllPrimaryKeys(candidate: Record<string, unknown>, primaryKeys: string[]): boolean {
  return primaryKeys.every((key) => Object.prototype.hasOwnProperty.call(candidate, key) && candidate[key] != null);
}

function isRefShape(candidate: Record<string, unknown>, primaryKeys: string[]): boolean {
  return Object.keys(candidate).every((key) => primaryKeys.includes(key));
}

function normalizeRefValue(value: unknown, binding: RefPathBinding, updatedObjects: EventUpdatedObject[]): unknown {
  if (!isRecord(value)) {
    return value;
  }
  if (!containsAllPrimaryKeys(value, binding.primaryKeys)) {
    return value;
  }
  if (isRefShape(value, binding.primaryKeys)) {
    return value;
  }
  const objectRef: Record<string, unknown> = {};
  for (const key of binding.primaryKeys) {
    objectRef[key] = value[key];
  }
  updatedObjects.push({
    object_type: binding.objectType,
    object_ref: objectRef,
    object: value,
  });
  return objectRef;
}

function applyBindingAtPath(current: unknown, binding: RefPathBinding, pathIndex: number, updatedObjects: EventUpdatedObject[]): void {
  if (pathIndex >= binding.path.length) {
    return;
  }
  const segment = binding.path[pathIndex];
  if (segment === '*') {
    if (Array.isArray(current)) {
      for (const item of current) {
        applyBindingAtPath(item, binding, pathIndex + 1, updatedObjects);
      }
    }
    return;
  }
  if (!isRecord(current)) {
    return;
  }
  const nextValue = current[segment];
  if (nextValue == null) {
    return;
  }
  if (pathIndex === binding.path.length - 1) {
    current[segment] = normalizeRefValue(nextValue, binding, updatedObjects);
    return;
  }
  applyBindingAtPath(nextValue, binding, pathIndex + 1, updatedObjects);
}

function normalizePayloadRefs(payload: Record<string, unknown>, bindings: RefPathBinding[]): EventUpdatedObject[] {
  const updatedObjects: EventUpdatedObject[] = [];
  for (const binding of bindings) {
    applyBindingAtPath(payload, binding, 0, updatedObjects);
  }
  return updatedObjects;
}

export interface ActionOutcome<TOutput> {
  output: TOutput;
  additionalEvents: DomainEvent[];
}

export type ActionOutcomeValue<TOutput> = TOutput | ActionOutcome<TOutput>;

export interface EventPublishMetadata {
  traceId: string;
  source: string;
  attributes?: Record<string, string>;
}

export function just<TOutput>(output: TOutput): ActionOutcome<TOutput> {
  return { output, additionalEvents: [] };
}

export function withEvents<TOutput>(output: TOutput, ...additionalEvents: DomainEvent[]): ActionOutcome<TOutput> {
  return { output, additionalEvents };
}

export function toActionOutcome<TOutput>(value: ActionOutcomeValue<TOutput>): ActionOutcome<TOutput> {
  if (value && typeof value === 'object' && 'output' in value && 'additionalEvents' in value) {
    return value as ActionOutcome<TOutput>;
  }
  return just(value as TOutput);
}

export function createCreateOrderResultEvent(payload: EventContracts.CreateOrderResult): DomainEvent {
  return { type: 'CreateOrderResult', payload };
}

export function createPaymentCapturedEvent(payload: EventContracts.PaymentCaptured): DomainEvent {
  return { type: 'PaymentCaptured', payload };
}

export function createOrderApproveTransitionEvent(payload: EventContracts.OrderApproveTransition): DomainEvent {
  return { type: 'OrderApproveTransition', payload };
}

export function createOrderShipTransitionEvent(payload: EventContracts.OrderShipTransition): DomainEvent {
  return { type: 'OrderShipTransition', payload };
}

function toEventWireEnvelope(event: DomainEvent, metadata: EventPublishMetadata): EventWireEnvelope {
  switch (event.type) {
    case 'CreateOrderResult': {
      const payload = cloneJsonLike(event.payload) as Record<string, unknown>;
      const updatedObjects = normalizePayloadRefs(payload, [
          { objectType: 'Order', path: ['order'], primaryKeys: ['orderId'] },
        ]);
      return {
        event_id: createEventId(),
        trace_id: metadata.traceId,
        event_type: 'CreateOrderResult',
        schema_version: '2.0.0',
        occurred_at: nowIso(),
        source: metadata.source,
        payload,
        attributes: metadata.attributes,
        updated_objects: updatedObjects.length ? updatedObjects : undefined,
      };
    }
    case 'PaymentCaptured': {
      const payload = cloneJsonLike(event.payload) as Record<string, unknown>;
      const updatedObjects = normalizePayloadRefs(payload, [
          { objectType: 'Order', path: ['order'], primaryKeys: ['orderId'] },
        ]);
      return {
        event_id: createEventId(),
        trace_id: metadata.traceId,
        event_type: 'PaymentCaptured',
        schema_version: '2.0.0',
        occurred_at: nowIso(),
        source: metadata.source,
        payload,
        attributes: metadata.attributes,
        updated_objects: updatedObjects.length ? updatedObjects : undefined,
      };
    }
    case 'OrderApproveTransition': {
      const payload = cloneJsonLike(event.payload) as Record<string, unknown>;
      const updatedObjects = normalizePayloadRefs(payload, []);
      return {
        event_id: createEventId(),
        trace_id: metadata.traceId,
        event_type: 'OrderApproveTransition',
        schema_version: '2.0.0',
        occurred_at: nowIso(),
        source: metadata.source,
        payload,
        attributes: metadata.attributes,
        updated_objects: updatedObjects.length ? updatedObjects : undefined,
      };
    }
    case 'OrderShipTransition': {
      const payload = cloneJsonLike(event.payload) as Record<string, unknown>;
      const updatedObjects = normalizePayloadRefs(payload, []);
      return {
        event_id: createEventId(),
        trace_id: metadata.traceId,
        event_type: 'OrderShipTransition',
        schema_version: '2.0.0',
        occurred_at: nowIso(),
        source: metadata.source,
        payload,
        attributes: metadata.attributes,
        updated_objects: updatedObjects.length ? updatedObjects : undefined,
      };
    }
    default:
      throw new Error(`Unsupported domain event: ${(event as { type?: string }).type ?? 'unknown'}`);
  }
}

export async function publishDomainEvents(
  eventPublisher: EventPublisher,
  events: DomainEvent[],
  metadata: EventPublishMetadata,
): Promise<void> {
  if (!events.length) {
    return;
  }
  const envelopes = events.map((event) => toEventWireEnvelope(event, metadata));
  await eventPublisher.publishBatch(envelopes);
}

export { EventPublisher, EventWireEnvelope, NoOpEventPublisher };
